# Copyright (c) 2014-2016. The SimGrid Team. All rights reserved.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the license (GNU LGPL) which comes with this package.

# The simcalls are given as C-like signatures (one per line):
#
# int foo(int x, int y);
# int foo(int x, int y) [[block]];
# int foo(int x, int y) [[nohandler]];
# int foo(int x, int y) [[block, nohandler]];
#
# The `block` attribut is used for calls which do not return in the same
# scheduling round. The answer requires some interaction with SURF,
# even if this can still occure at the same timestamp under some
# circonstances (eg if the surf_action cannot start because of resources
# that are down) examples: things that last some time (communicate, execute,
# mutex_lock).
#
# The `nohandler` is used to disable handlers.
# I wish we could completely remove the handlers as their only use is
# to adapt the interface between the exported symbol that is visible
# by the user applications and the internal symbol that is implemented 
# by the kernel. 
# The only remaining use of that mechanism is to add the caller
# identity as a parameter of internal call, but that could be
# automatized too (eg by having a special parameter type called "self")

# Please note that in addition to completing this file with your new simcall,
# you should complete the libsmx.c file by adding the corresponding function
# (aka. stub). Anyway, if you omit to do it, the invocation of ./simcalls.py will notify you ;)
# If you want to remove an handler, it is important to remove although
# the corresponding code (simcall_HANDLER_name_of_simcall(xxx) (note that comment the code 
# is not sufficient, the python script does not check whether the code is commented or not).
# Last but not the least, you should declare the new simix call in
# ./include/simgrid/simix.h (otherwise you will get a warning at the
# compilation time)

void vm_suspend(sg_host_t ind_vm);
void vm_resume(sg_host_t ind_vm);
void vm_shutdown(sg_host_t ind_vm);
void vm_save(sg_host_t ind_vm);
void vm_restore(sg_host_t ind_vm);

void process_kill(smx_process_t process);
void process_killall(int reset_pid);
void process_cleanup(smx_process_t process) [[nohandler]];
void process_suspend(smx_process_t process) [[block]];
void process_resume(smx_process_t process);
void process_set_host(smx_process_t process, sg_host_t dest);
int  process_is_suspended(smx_process_t process) [[nohandler]];
int  process_join(smx_process_t process, double timeout) [[block]];
int  process_sleep(double duration) [[block]];

smx_synchro_t execution_start(const char* name, double flops_amount, double priority, double bound, unsigned long affinity_mask);
smx_synchro_t execution_parallel_start(const char* name, int host_nb, sg_host_t* host_list, double* flops_amount, double* bytes_amount, double amount, double rate) [[nohandler]];
void          execution_cancel(smx_synchro_t execution) [[nohandler]];
void          execution_set_priority(smx_synchro_t execution, double priority) [[nohandler]];
void          execution_set_bound(smx_synchro_t execution, double bound) [[nohandler]];
void          execution_set_affinity(smx_synchro_t execution, sg_host_t ws, unsigned long mask) [[nohandler]];
int           execution_wait(smx_synchro_t execution) [[block]];

void          process_on_exit(smx_process_t process, int_f_pvoid_pvoid_t fun, void* data) [[nohandler]];
void          process_auto_restart_set(smx_process_t process, int auto_restart) [[nohandler]];
smx_process_t process_restart(smx_process_t process);

smx_mailbox_t mbox_create(const char* name) [[nohandler]];
void          mbox_set_receiver(smx_mailbox_t mbox, smx_process_t receiver) [[nohandler]];

smx_synchro_t comm_iprobe(smx_mailbox_t mbox, int type, int src, int tag, simix_match_func_t match_fun, void* data);
void          comm_send(smx_process_t sender, smx_mailbox_t mbox, double task_size, double rate, void* src_buff, size_t src_buff_size, simix_match_func_t match_fun, simix_copy_data_func_t copy_data_fun, void* data, double timeout) [[block]];
smx_synchro_t comm_isend(smx_process_t sender, smx_mailbox_t mbox, double task_size, double rate, void* src_buff, size_t src_buff_size, simix_match_func_t match_fun, simix_clean_func_t clean_fun, simix_copy_data_func_t copy_data_fun, void* data, int detached);
void          comm_recv(smx_process_t receiver, smx_mailbox_t mbox, void* dst_buff, size_t* dst_buff_size, simix_match_func_t match_fun, simix_copy_data_func_t copy_data_fun, void* data, double timeout, double rate) [[block]];
smx_synchro_t comm_irecv(smx_process_t receiver, smx_mailbox_t mbox, void* dst_buff, size_t* dst_buff_size, simix_match_func_t match_fun, simix_copy_data_func_t copy_data_fun, void* data, double rate);
int           comm_waitany(xbt_dynar_t comms) [[block]];
void          comm_wait(smx_synchro_t comm, double timeout) [[block]];
int           comm_test(smx_synchro_t comm) [[block]];
int           comm_testany(smx_synchro_t* comms, size_t count) [[block]];

smx_mutex_t mutex_init();
void        mutex_lock(smx_mutex_t mutex) [[block]];
int         mutex_trylock(smx_mutex_t mutex);
void        mutex_unlock(smx_mutex_t mutex);

smx_cond_t cond_init() [[nohandler]];
void       cond_signal(smx_cond_t cond) [[nohandler]];
void       cond_wait(smx_cond_t cond, smx_mutex_t mutex) [[block]];
void       cond_wait_timeout(smx_cond_t cond, smx_mutex_t mutex, double timeout) [[block]];
void       cond_broadcast(smx_cond_t cond) [[nohandler]];

smx_sem_t sem_init(unsigned int capacity) [[nohandler]];
void      sem_release(smx_sem_t sem);
int       sem_would_block(smx_sem_t sem);
void      sem_acquire(smx_sem_t sem) [[block]];
void      sem_acquire_timeout(smx_sem_t sem, double timeout) [[block]];
int       sem_get_capacity(smx_sem_t sem);

sg_size_t   file_read(smx_file_t fd, sg_size_t size, sg_host_t host) [[block]];
sg_size_t   file_write(smx_file_t fd, sg_size_t size, sg_host_t host) [[block]];
smx_file_t  file_open(const char* fullpath, sg_host_t host) [[block]];
int         file_close(smx_file_t fd, sg_host_t host) [[block]];
int         file_unlink(smx_file_t fd, sg_host_t host) [[nohandler]];
sg_size_t   file_get_size(smx_file_t fd);
sg_size_t   file_tell(smx_file_t fd);
int         file_seek(smx_file_t fd, sg_offset_t offset, int origin);
xbt_dynar_t file_get_info(smx_file_t fd);
int         file_move(smx_file_t fd, const char* fullpath);

sg_size_t  storage_get_free_size(smx_storage_t storage);
sg_size_t  storage_get_used_size(smx_storage_t name);
xbt_dict_t storage_get_properties(smx_storage_t storage) [[nohandler]];
xbt_dict_t storage_get_content(smx_storage_t storage) [[nohandler]];

xbt_dict_t asr_get_properties(const char* name);
int        mc_random(int min, int max);
void       set_category(smx_synchro_t synchro, const char* category) [[nohandler]];

void       run_kernel(std::function<void()> const* code) [[nohandler]];
void       run_blocking(std::function<void()> const* code) [[block,nohandler]];
