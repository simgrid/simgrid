#! /usr/bin/perl

# gras_stub_generator - creates the main() to use a GRAS program

# Authors: Martin Quinson
# Copyright (C) 2003 the OURAGAN project.
  
# This program is free software; you can redistribute it and/or modify it
# under the terms of the license (GNU LGPL) which comes with this package.
  
use strict;
use warnings;


sub usage {
    my ($msg)=@_;
    fail ($msg? "gras_stub_generator: $msg\n":"").
	 "gras_stub_generator: USAGE\n".
	 "  gras_stub_generator project_name deployment_file\n"
}

my ($project,$deploy_file)=@ARGV;

$project && $deploy_file || usage();

my (%process);

open (DEPLOY, $deploy_file) || usage("Cannot open $deploy_file: $!");
my $linenum=0;
while (<DEPLOY>) {
    $linenum++;
    /^\W*\w*\W*(\w*)/ || usage("$deploy_file:$linenum: Parse error");
    $process{$1}=1;
}

my $warn="/***********\n * DO NOT EDIT! THIS FILE WERE AUTOMATICALLY GENERATED FROM $deploy_file BY gras_stub_generator\n ***********/\n";

#####
# Generate the file for the simulator
#####

open (OUT,">_${project}_simulator.c") || die "Cannot open _${project}_simulator,c: $!";
print OUT <<EOF
$warn

#include <stdlib.h>
#include <stdio.h>
#include <msg.h>
#include <gras.h>

EOF
 ;
foreach (keys %process) { print OUT "int $_(int argc,char *argv[]);\n";        }
print OUT "\n";
foreach (keys %process) { print OUT "int launch_$_(int argc,char *argv[]);\n"; }
print OUT "\n$warn\n";

foreach (keys %process) {
    print OUT<<EOF
int launch_$_(int argc, char *argv[]) {
    
  if (gras_process_init()) exit(1);
  $_(argc,argv);
  if (gras_process_exit()) exit(1);

  return 0;
}

EOF
    ;
}
print OUT "\n$warn\n";

print OUT <<EOF
int main (int argc,char *argv[]) {
    
  if (argc < 3) {
    fprintf(stderr, "Usage: %s platform_file application_description.txt [extra args]\\n",argv[0]);
    exit(1);
  }

  /* GRAS setup */
  gras_init(&argc, argv);

  /*  Simulation setup */
  MSG_global_init();
  MSG_set_verbosity(MSG_SILENT);
  MSG_set_channel_number(GRAS_MAX_CHANNEL);
  MSG_create_environment(argv[1]);

  /*  Application deployment */
EOF
;
foreach (keys %process) {
    print OUT "  MSG_function_register(\"$_\", launch_$_);\n";
}
print OUT <<EOF

  MSG_launch_application(argv[2]);

  /*  Run the simulation */
  MSG_main();

  return 0;
}
$warn
EOF
    ;
close OUT || die "Cannot write _${project}_simulator,c: $!";

#####
# Generate the files for the real life
#####
foreach my $pname (keys %process) {
    open (OUT,">_${project}_$pname.c") || die "Cannot open _${project}_$pname,c: $!";
    print OUT <<EOF
$warn
#include <stdio.h>
#include <signal.h>
#include <gras.h>

/* user code */
int $pname(int argc, char *argv[]);

$warn

int main(int argc, char *argv[]){
  int errcode;

  gras_init(&argc,argv);
  gras_process_init();
  errcode=$pname(argc,argv);
  gras_process_exit();
  gras_exit();
 
  return errcode;
}

$warn
EOF
;
    close OUT || die "Cannot write _${project}_$pname,c: $!";
}

#####
# Outputs the Makefile.am snippet
#####

print ">>> Files for project '$project' successfully generated.\n";
print ">>> Add (and edit) the following to you Makefile.am:\n\n";

print "# AUTOMAKE variable definition\n";
print "INCLUDES= \@CFLAGS_GRAS\@ \@CFLAGS_XML\@ \@CFLAGS_SimGrid\@\n\n";
print "PROGRAMS=${project}_simulator ";

foreach (keys %process) {
    print "${project}_$_ ";
}
print "\n\n${project}_simulator_SOURCES=\t_${project}_simulator.c $project.c\n";
foreach (keys %process) {
    print "${project}_${_}_SOURCES=\t_${project}_${_}.c $project.c\n";
}

print "\n\n${project}_simulator_LDADD=\tpath/to/libgrassg.a \@LIBS_SimGrid\@ \@LIBS_XML\@\n";
foreach (keys %process) {
    print "${project}_${_}_LDADD=\tpath/to/libgrasrl.a\n";
}

print "\n# cleanup temps\n";
print "CLEANFILES= _${project}_simulator.c ";
foreach (keys %process) {
    print "_${project}_$_.c ";
}
print "\n";

print "\n# generate temps\n";
# A rule to generate the source file each time the deployment file changes
foreach (keys %process) {
    print "_${project}_$_.c ";
}
print "_${project}_simulator.c: $deploy_file\n";
print "\tgras_stub_generator $project $deploy_file >/dev/null\n";


print "\n>>> Bye.\n"
