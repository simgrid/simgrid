# Smpi Allreduce collectives tests

p Test allreduce
$ $VALGRIND_NO_LEAK_CHECK ${bindir:=.}/../../../smpi_script/bin/smpirun -wrapper "${bindir:=.}/../../../bin/simgrid-mc" -map -hostfile ../hostfile_coll -platform  ${platfdir:=.}/small_platform.xml -np 4 --log=xbt_cfg.thres:critical ${bindir:=.}/coll-allreduce-with-leaks --log=smpi_config.thres:warning --cfg=smpi/display-allocs:yes --cfg=smpi/simulate-computation:no --log=smpi_coll.thres:error --log=smpi_mpi.thres:error --log=smpi_pmpi.thres:error --cfg=smpi/list-leaks:10 --log=no_loc
> [rank 0] -> Tremblay
> [rank 1] -> Tremblay
> [rank 2] -> Tremblay
> [rank 3] -> Tremblay
> [0.000000] [mc_safety/INFO] Check a safety property. Reduction is: dpor.
> [0.000000] [smpi_utils/INFO] Probable memory leaks in your code: SMPI detected 8 unfreed MPI handles :
> [0.000000] [smpi_utils/INFO] To get more information (location of allocations), compile your code with -trace-call-location flag of smpicc/f90
> [0.000000] [smpi_utils/INFO] 4 leaked handles of type MPI_Comm
> [0.000000] [smpi_utils/INFO] 4 leaked handles of type MPI_Group
> [0.000000] [smpi_utils/INFO] Probable memory leaks in your code: SMPI detected 4 unfreed buffers : display types and addresses (n max) with --cfg=smpi/list-leaks:n.
> Running smpirun with -wrapper "valgrind --leak-check=full" can provide more information
> [0.000000] [smpi_utils/INFO] Leaked buffer of size 16
> [0.000000] [smpi_utils/INFO] Leaked buffer of size 16
> [0.000000] [smpi_utils/INFO] Leaked buffer of size 16
> [0.000000] [smpi_utils/INFO] Leaked buffer of size 16
> [0.000000] [smpi_utils/INFO] Memory Usage: Simulated application allocated 128 bytes during its lifetime through malloc/calloc calls.
> Largest allocation at once from a single process was 16 bytes, at coll-allreduce-with-leaks.c:27. It was called 4 times during the whole simulation.
> If this is too much, consider sharing allocations for computation buffers.
> This can be done automatically by setting --cfg=smpi/auto-shared-malloc-thresh to the minimum size wanted size (this can alter execution if data content is necessary)
> 
> [0.000000] [smpi_utils/INFO] Probable memory leaks in your code: SMPI detected 8 unfreed MPI handles :
> [0.000000] [smpi_utils/INFO] To get more information (location of allocations), compile your code with -trace-call-location flag of smpicc/f90
> [0.000000] [smpi_utils/INFO] 4 leaked handles of type MPI_Comm
> [0.000000] [smpi_utils/INFO] 4 leaked handles of type MPI_Group
> [0.000000] [smpi_utils/INFO] Probable memory leaks in your code: SMPI detected 4 unfreed buffers : display types and addresses (n max) with --cfg=smpi/list-leaks:n.
> Running smpirun with -wrapper "valgrind --leak-check=full" can provide more information
> [0.000000] [smpi_utils/INFO] Leaked buffer of size 16
> [0.000000] [smpi_utils/INFO] Leaked buffer of size 16
> [0.000000] [smpi_utils/INFO] Leaked buffer of size 16
> [0.000000] [smpi_utils/INFO] Leaked buffer of size 16
> [0.000000] [smpi_utils/INFO] Memory Usage: Simulated application allocated 128 bytes during its lifetime through malloc/calloc calls.
> Largest allocation at once from a single process was 16 bytes, at coll-allreduce-with-leaks.c:27. It was called 4 times during the whole simulation.
> If this is too much, consider sharing allocations for computation buffers.
> This can be done automatically by setting --cfg=smpi/auto-shared-malloc-thresh to the minimum size wanted size (this can alter execution if data content is necessary)
> 
> [0.000000] [mc_safety/INFO] No property violation found.
> [0.000000] [mc_safety/INFO] Expanded states = 63
> [0.000000] [mc_safety/INFO] Visited states = 500
> [0.000000] [mc_safety/INFO] Executed transitions = 484
