/*! \page faq Frequently Asked Questions

\htmlinclude .FAQ.doc.toc

\section faq_simgrid I'm new to SimGrid. I have some questions. Where should I start?

You are at the right  place... Having a look to these
<a href="http://www.loria.fr/~quinson/articles/simgrid-tutorial.pdf">the tutorial slides</a> 
(or to these <a href="http://graal.ens-lyon.fr/~alegrand/articles/slides_g5k_simul.pdf">old slides</a>,
or to these
<a href="http://graal.ens-lyon.fr/~alegrand/articles/Simgrid-Introduction.pdf">"obsolete" slides</a>)
may give you some insights on what SimGrid can help you to do and what
are its limitations. Then you definitely should read the \ref
MSG_examples. The \ref GRAS_tut can also help you.

If you are stuck at any point and if this FAQ cannot help you, please drop us a
mail to the user mailing list: <simgrid-user@lists.gforge.inria.fr>.

\subsection faq_interfaces What is the difference between MSG, SimDag, and GRAS? Do they serve the same purpose?

It depend on how you define "purpose", I guess ;)

They all allow you to build a prototype of application which you can run
within the simulator afterward. They all share the same simulation kernel,
which is the core of the SimGrid project. They differ by the way you express
your application.

With SimDag, you express your code as a collection of interdependent
parallel tasks. So, in this model, applications can be seen as a DAG of
tasks. This is the interface of choice for people wanting to port old
code designed for SimGrid v1 or v2 to the framework current version.

With both GRAS and MSG, your application is seen as a set of communicating
processes, exchanging data by the way of messages and performing computation
on their own.

The difference between both is that MSG is somehow easier to use, but GRAS
is not limited to the simulator. Once you're done writing your GRAS code,
you can run your code both in the simulator or on a real platform. For this,
there is two implementations of the GRAS interface, one for simulation, one
for real execution. So, you just have to relink your code to chose one of
both world. 

\subsection faq_generic First steps with SimGrid

If you decide to go for the MSG interface, please read carefully the
\ref MSG_examples. You'll find in \ref MSG_ex_master_slave a very
simple consisting of a master (that owns a bunch of tasks and
distributes them) , some slaves (that process tasks whenever they
receive one) and some forwarder agents (that simply pass the tasks
they receive to some slaves).

If you decide to go for the GRAS interface, you should definitively
read the \ref GRAS_tut. The first section constitutes an introduction
to the tool and presents the model we use. The second section
constitutes a complete step-by-step tutorial building a distributed
application from the beginning and exemplifying most of the GRAS
features in the process. The last section groups some HOWTOS
highlighting a given feature of the framework in a more concise way.

If you decide to go for another interface, I'm afraid your only sources
of information will be the source code and the mailing lists...

\subsection faq_visualization Visualizing and analyzing the results

It is sometime convenient to "see" how the agents are behaving. If you
like colors, you can use <tt>tools/MSG_visualization/colorize.pl </tt>
as a filter to your MSG outputs. It works directly with INFO. Beware,
INFO() prints on stderr. Do not forget to redirect if you want to
filter (e.g. with bash): 
\verbatim 
./msg_test small_platform.xml small_deployment.xml 2>&1 | ../../tools/MSG_visualization/colorize.pl
\endverbatim

We also have a more graphical output. Have a look at section \ref faq_tracing.

\subsection faq_C Argh! Do I really have to code in C?

Up until now, there is no binding for other languages. If you use C++,
you should be able to use the SimGrid library as a standard C library
and everything should work fine (simply <i>link</i> against this
library; recompiling SimGrid with a C++ compiler won't work and it
wouldn't help if you could).

In fact, we are currently working on Java bindings of MSG to allow
all the undergrad students of the world to use this tool. This is a
little more tricky than I would have expected, but the work is moving
fast forward [2006/05/13]. More languages are evaluated, but for now,
we do not feel a real demand for any other language. Please speak up!

\section faq_installation Installing the SimGrid library

Many people have been asking me questions on how to use SimGrid. Quite
often, the questions were not really about SimGrid but on the
installation process. This section is intended to help people that are
not familiar with compiling C files under UNIX. If you follow these
instructions and still have some troubles, drop an e-mail to
<simgrid-user@lists.gforge.inria.fr>.

\subsection faq_compiling Compiling SimGrid from a stable archive

First of all, you need to download the latest version of SimGrid from 
<a href="http://gforge.inria.fr/frs/?group_id=12">here</a>.
Suppose you have uncompressed SimGrid in some temporary location of
your home directory (say <tt>/home/joe/tmp/simgrid-3.0.1 </tt>). The
simplest way to use SimGrid is to install it in your home
directory. Change your directory to
<tt>/home/joe/tmp/simgrid-3.0.1</tt> and type

\verbatim
./configure --prefix=$HOME
make
make install
\endverbatim

If at some point, something fails, check the section \ref faq_trouble_compil .
If it does not help, you can report this problem to the
list but, please, avoid sending a laconic mail like "There is a problem. Is it
okay?". Send the config.log file which is automatically generated by
configure. Try to capture both the standard output and the error output of the
<tt>make</tt> command with <tt>script</tt>. There is no way for us to help you
without the relevant bits of information.

Now, the following directory should have been created : 

      \li <tt>/home/joe/doc/simgrid/html/</tt>
      \li <tt>/home/joe/lib/</tt>
      \li <tt>/home/joe/include/</tt>

SimGrid is not a binary, it is a library. Both a static and a dynamic
version are available. Here is what you can find if you try a <tt>ls
/home/joe/lib</tt>:

\verbatim libsimgrid.a libsimgrid.la libsimgrid.so libsimgrid.so.0 libsimgrid.so.0.0.1
\endverbatim

Thus, there is two ways to link your program with SimGrid:
      \li Either you use the static version, e.g 
\verbatim gcc libsimgrid.a -o MainProgram MainProgram.c
\endverbatim
          In this case, all the SimGrid functions are directly
          included in <tt>MainProgram</tt> (hence a bigger binary).
      \li Either you use the dynamic version (the preferred method)
\verbatim gcc -lsimgrid -o MainProgram MainProgram.c
\endverbatim
          In this case, the SimGrid functions are not included in
          <tt>MainProgram</tt> and you need to set your environment
          variable in such a way that <tt>libsimgrid.so</tt> will be
          found at runtime. This can be done by adding the following
          line in your .bashrc (if you use bash and if you have
          installed the SimGrid libraries in your home directory):
\verbatim export LD_LIBRARY_PATH=$HOME/lib/:$LD_LIBRARY_PATH
\endverbatim

\subsection faq_compiling_java Java bindings don't get compiled

The configure script detects automatically whether you have the
softwares needed to use the Java bindings or not. At the end of the
configure, you can see the configuration picked by the script, which
should look similar to 
\verbatim Configuration of package simgrid' (version 3.3.4-svn) on
little64 (=4):

	 Compiler:	 gcc (version: )
	 
	 CFlags:       	  -O3 -finline-functions -funroll-loops -fno-strict-aliasing -Wall -Wunused -Wmissing-prototypes -Wmissing-declarations -Wpointer-arith -Wchar-subscripts -Wcomment -Wformat -Wwrite-strings -Wno-unused-function -Wno-unused-parameter -Wno-strict-aliasing -Wno-format-nonliteral -Werror -g3
	 CPPFlags:   
         LDFlags:	 
				   
         Context backend: ucontext
         Compile Java: no
							 
         Maintainer mode: no
         Supernovae mode: yes
\endverbatim	   

In this example, Java backends won't be compiled. 

On Debian-like systems (which includes ubuntu), you need the following
packages: sun-java6-jdk libgcj10-dev. If you cannot find the
libgcj10-dev, try another version, like libgcj9-dev (on Ubuntu before
9.10) or libgcj11-dev (not released yet, but certainly one day).
Please note that you need to activate the contrib and non-free
repositories in Debian, and the universe ones in Ubuntu. Java comes at
this price...

\subsection faq_compiling_snapshoot SimGrid development snapshots

We have very high standards on software quality, and we are reluctant releasing
a stable release as long as there is still some known bug in the code base. In
addition, we added quite an extensive test base, making sure that we correctly
test the most important parts of the tool. 

As an unfortunate conclusion, there may be some time between the stable
releases. If you want to benefit from the most recent features we introduced,
but don't want to take the risk of an untested version from the SVN, then
development snapshots are done for you. 

These are pre-releases of SimGrid that still fail some tests about features
that almost nobody use, or on platforms not being in our core target (which is
Linux, Mac, other Unixes and Windows, from the most important to the less
one). That means that using this development releases should be safe for most
users. 

These archives can be found on 
<a href="http://www.loria.fr/~quinson/simgrid.html">this web page</a>. Once you 
got the lastest archive, you can compile it just like any archive (see above).

\subsection faq_compiling_svn Compiling SimGrid from the SVN

The project development takes place in the SVN, where all changes are
committed when they happen. Then every once in a while, we make sure that the
code quality meets our standard and release an archive from the code in the
SVN. We afterward go back to the development in the SVN. So, if you need a
recently added feature and can afford some little problem with the stability
of the lastest features, you may want to use the SVN version instead of a
released one.

For that, you first need to get the "simgrid" module from
<a href="http://gforge.inria.fr/scm/?group_id=12">here</a>. 

You won't find any <tt>configure</tt> and a few other things
(<tt>Makefile.in</tt>'s, documentation, ...) will be missing as well. The
reason for that is that all these files have to be regenerated using the
latest versions of <tt>autoconf</tt>, <tt>libtool</tt>, <tt>automake</tt>
(>1.9) and <tt>doxygen</tt> (>1.4). To generate the <tt>configure</tt> and
the <tt>Makefile.in</tt>'s, you just have to launch the <tt>bootstrap</tt>
command that resides in the top of the source tree. Then just follow the
instructions of Section \ref faq_compiling.

We insist on the fact that you really need the latest versions of
autoconf, automake and libtool. Doing this step on exotic architectures/systems
(i.e. anything different from a recent linux distribution) may be
... uncertain. If you need to compile the SVN version on a machine where all these
dependencies are not met, the easiest is to do <tt>make dist</tt> in the SVN
directory of another machine where all dependencies are met. It will create an
archive you may deploy on other sites just as a regular stable release.

In summary, the following commands will checkout the SVN, regenerate the
configure script and friends, configure SimGrid and build it.

\verbatim svn checkout svn://scm.gforge.inria.fr/svn/simgrid/simgrid/trunk simgrid
cd simgrid
./bootstrap
./configure --enable-maintainer-mode --prefix=<where to install SimGrid>
make \endverbatim

Then, if you want to install SimGrid on the current box, just do:
\verbatim make install \endverbatim

If you want to build an snapshot of the SVN to deploy it on another box (for
example because the other machine don't have the autotools), do:
\verbatim make dist \endverbatim

Moreover, you should never call the autotools manually since you must run
them in a specific order with specific arguments. Most of the times, the
makefiles will automatically call the tools for you. When it's not possible
(such as the first time you checkout the SVN), use the ./bootstrap command
to call them explicitly.


\subsection faq_setting_MSG Setting up your own MSG code

Do not build your simulator by modifying the SimGrid examples.  Go
outside the SimGrid source tree and create your own working directory
(say <tt>/home/joe/SimGrid/MyFirstScheduler/</tt>).

Suppose your simulation has the following structure (remember it is
just an example to illustrate a possible way to compile everything;
feel free to organize it as you want).

      \li <tt>sched.h</tt>: a description of the core of the
          scheduler (i.e. which functions are can be used by the
          agents). For example we could find the following functions
          (master, forwarder, slave).

      \li <tt>sched.c</tt>: a C file including <tt>sched.h</tt> and
          implementing the core of the scheduler. Most of these
          functions use the MSG functions defined in section \ref
          msg_gos_functions.

      \li <tt>masterslave.c</tt>: a C file with the main function, i.e.
          the MSG initialization (MSG_global_init()), the platform
          creation (e.g. with MSG_create_environment()), the
          deployment phase (e.g. with MSG_function_register() and
          MSG_launch_application()) and the call to
          MSG_main()).

To compile such a program, we suggest to use the following
Makefile. It is a generic Makefile that we have used many times with
our students when we teach the C language.

\verbatim
all: masterslave 
masterslave: masterslave.o sched.o

INSTALL_PATH = $$HOME
CC = gcc
PEDANTIC_PARANOID_FREAK =       -O0 -Wshadow -Wcast-align \
				-Waggregate-return -Wmissing-prototypes -Wmissing-declarations \
				-Wstrict-prototypes -Wmissing-prototypes -Wmissing-declarations \
				-Wmissing-noreturn -Wredundant-decls -Wnested-externs \
				-Wpointer-arith -Wwrite-strings -finline-functions
REASONABLY_CAREFUL_DUDE =	-Wall
NO_PRAYER_FOR_THE_WICKED =	-w -O2 
WARNINGS = 			$(REASONABLY_CAREFUL_DUDE)
CFLAGS = -g $(WARNINGS)

INCLUDES = -I$(INSTALL_PATH)/include
DEFS = -L$(INSTALL_PATH)/lib/
LDADD = -lm -lsimgrid 
LIBS = 

%: %.o
	$(CC) $(INCLUDES) $(DEFS) $(CFLAGS) $^ $(LIBS) $(LDADD) -o $@ 

%.o: %.c
	$(CC) $(INCLUDES) $(DEFS) $(CFLAGS) -c -o $@ $<

clean:
	rm -f $(BIN_FILES) *.o *~
.SUFFIXES:
.PHONY : clean

\endverbatim

The first two lines indicates what should be build when typing make
(<tt>masterslave</tt>) and of which files it is to be made of
(<tt>masterslave.o</tt> and <tt>sched.o</tt>). This makefile assumes
that you have set up correctly your <tt>LD_LIBRARY_PATH</tt> variable
(look, there is a <tt>LDADD = -lm -lsimgrid</tt>). If you prefer using
the static version, remove the <tt>-lsimgrid</tt> and add a
<tt>$(INSTALL_PATH)/lib/libsimgrid.a</tt> on the next line, right
after the <tt>LIBS = </tt>.

More generally, if you have never written a Makefile by yourself, type
in a terminal : <tt>info make</tt> and read the introduction. The
previous example should be enough for a first try but you may want to
perform some more complex compilations...

\subsection faq_setting_GRAS Setting up your own GRAS code

If you use the GRAS interface instead of the MSG one, then previous section
is not the better source of information. Instead, you should check the GRAS
tutorial in general, and the \ref GRAS_tut_tour_setup in particular.

\section faq_cmake CMAKE

\subsection faq_intro Some generalitty

\subsubsection faq_intro1 What is Cmake?

CMake is a family of tools designed to build, test and package software. CMake is used to control the software compilation process using simple platform and compiler independent configuration files. CMake generates native makefiles and workspaces that can be used in the compiler environment of your choice. For more information see official web site <a href="http://www.cmake.org/">here</a>.

\subsubsection faq_intro2 Why cmake?

CMake permits to developers to compil projects on different plateform. Then many tools are embedded like ctest for making test, a link to cdash for vizualise results but also test coverage and bug reports. 

\subsubsection faq_intro3 What cmake need?

CMake needs some prerequists like :
  \li make
  \li c, c++ and java compiler regards to developers
  \li ccmake for graphical used of CMake
  \li cmake <a href="http://www.cmake.org/cmake/resources/software.html">(download page)</a>

For windows only : 
  \li Visual C++ 2010 Express <a href="http://www.microsoft.com/express/Downloads/#2010-Visual-CPP">(download page)</a>
  \li cmake <a href="http://www.cmake.org/cmake/resources/software.html">(download page)</a>
  \li Set CC, CXX, INCLUDE, LIB and RC to environment variables.
\verbatim
SET --> CC	TO --> C:\MicrosoftVisualStudio10\VC\bin\cl
    --> CXX	   --> C:\MicrosoftVisualStudio10\VC\bin\cl
    --> INCLUDE	   --> C:\MicrosoftVisualStudio10\VC\include;C:\Program Files\Microsoft SDKs\Windows\v7.OA\Include
    --> LIB	   --> C:\MicrosoftVisualStudio10\VC\lib;C:\Program Files\Microsoft SDKs\Windows\v7.OA\Lib
    --> RC	   --> C:\Program Files\Microsoft SDKs\Windows\v7.OA\bin\RC
\endverbatim
  \li Add to environment variable "Path" the path where to find nmake executable and some needed files.
\verbatim
......
;C\MicrosoftVisualStudio10\VC\bin
;C\MicrosoftVisualStudio10\Common7\IDE
;C:\Program Files\Microsoft SDKs\Windows\v7.OA\bin
;C:\Program Files\Microsoft SDKs\Windows\v7.OA\Lib
;C:\Program Files\Microsoft SDKs\Windows\v7.OA\bInclude
\endverbatim  
\subsection faq_cmakeoption Cmake options

\subsubsection faq_cmakeoption1 Liste of options

\verbatim
"cmake -D[name]=[value] ... ./"
 
[name] 		enable_gtnets			[value] ON/OFF or TRUE/FALSE or 1/0
		enable_java				ON/OFF or TRUE/FALSE or 1/0
		enable_lua				ON/OFF or TRUE/FALSE or 1/0
		enable_ruby				ON/OFF or TRUE/FALSE or 1/0
		enable_compile_optimizations		ON/OFF or TRUE/FALSE or 1/0
		enable_compile_warnings			ON/OFF or TRUE/FALSE or 1/0
		enable_smpi				ON/OFF or TRUE/FALSE or 1/0
		enable_maintainer_mode			ON/OFF or TRUE/FALSE or 1/0
		enable_supernovae			ON/OFF or TRUE/FALSE or 1/0
		enable_tracing 				ON/OFF or TRUE/FALSE or 1/0
		enable_coverage 			ON/OFF or TRUE/FALSE or 1/0
		enable_memcheck 			ON/OFF or TRUE/FALSE or 1/0 
		enable_model-checking			ON/OFF or TRUE/FALSE or 1/0

		gtnets_path				<path_to_gtnets_directory>
		prefix					<path_to_install_directory>
		BIBTEX2HTML 				<path_to_bibtex2html>
		with_context				auto/ucontext/pthread/window	 
\endverbatim
                                                                                                                                                          
\subsubsection faq_cmakeoption2 Options explaination

  \li enable_gtnets : set to true implie that user wants to use gtnets.

  \li enable_java : set to true implie that user wants to add java langage into simgrid compilation.

  \li enable_lua : set to true implie that user wants to add lua langage into simgrid compilation.

  \li enable_ruby : set to true implie that user wants to add ruby langage into simgrid compilation.

  \li enable_compile_optimizations : add flags "-O3 -finline-functions -funroll-loops -fno-strict-aliasing"

  \li enable_compile_warnings : add flags "-Wall -Wunused -Wmissing-prototypes -Wmissing-declarations -Wpointer-arith -Wchar-subscripts -Wcomment -Wformat -Wwrite-strings -Wno-unused-function -Wno-unused-parameter -Wno-strict-aliasing -Wno-format-nonliteral -Werror"

  \li enable_smpi : Set to true if you want to use smpi lib. Actually on simgrid v3.4.1 Mac doesn't support lib smpi.

  \li enable_maintainer_mode : set to true it remakes some files. 
\verbatim
include/surf/simgrid_dtd.h
include/xbt/graphxml.h

src/cunit_unit.c
src/ex_unit.c
src/dynar_unit.c
src/dict_unit.c
src/set_unit.c
src/swag_unit.c
src/xbt_str_unit.c
src/xbt_strbuff_unit.c
src/xbt_sha_unit.c
src/config_unit.c
src/xbt_synchro_unit.c
src/simgrid_units_main.c

src/simdag/dax_dtd.c
src/simdag/dax_dtd.h
src/simdag/dax_dtd.l

src/surf/simgrid_dtd.c
src/surf/simgrid_dtd.l

src/xbt/graphxml.c
src/xbt/graphxml.l

src/gras/DataDesc/ddt_parse.yy.c
\endverbatim
  \li enable_supernovae : set to true make one file for each lib and compile with those generated files.
\verbatim
/src/supernovae_sg.c
/src/supernovae_gras.c			
/src/supernovae_smpi.c
\endverbatim

  \li enable_tracing : To enable the generation of simulation traces for visualization

  \li enable_coverage : When set to true this option enable code coverage by setting -fprofile-arcs -ftest-coverage flags.

  \li enable_memcheck : When set to true this option enable tests for memcheck.

  \li enable_model-checking : Enable the model checking when set to true.

  \li gtnets_path : Path to gtnets install directory (ex /usr)

  \li prefix : Path where are installed lib/ doc/ and include/ directories (ex /usr/local)

  \li BIBTEX2HTML : Path where is installed bibtex2html.

  \li with context : specify which context the user wants to use.

\subsubsection faq_cmakeoption3 Initialisation

Those options are initialized the first time you launch "cmake ." whithout specified option.

\verbatim
enable_gtnets			on
enable_lua			on
enable_ruby			on
enable_java			off
enable_compile_optimizations	off
enable_compile_warnings		off
enable_smpi			on
enable_maintainer_mode		off
enable_supernovae		off
enable_tracing			off
enable_coverage 		off
enable_memcheck 		off
enable_model-checking		off

gtnets_path			null
prefix				null
BIBTEX2HTML 			null
with_context			auto
\endverbatim

\subsubsection faq_cmakeoption4 Option's cache and how to reset?

When options have been set they are keep into a cache file named "CMakeCache.txt". So if you want 
reset values you just delete this file located to the project directory.

\subsection faq_cmakecompilation Cmake compilation

\subsubsection faq_cmakecompilation1 With command line.

\verbatim
cmake -D[name]=[value] ... ./
make
\endverbatim

\subsubsection faq_cmakecompilation2 With ccmake tool.

\verbatim
"ccmake ./"
\endverbatim
Then follow instructions.

\subsubsection faq_cmakecompilation2bis Build out of source.

As cmake generate many files used for compilation, we recommand to make a build directory.
For examples you can make :

\verbatim
"navarrop@caraja:~/Developments$ cd simgrid/"
"navarrop@caraja:~/Developments/simgrid$ mkdir build_directory"
"navarrop@caraja:~/Developments/simgrid$ cd build_directory/"
"navarrop@caraja:~/Developments/simgrid/build_directory$ cmake ../"
"navarrop@caraja:~/Developments/simgrid/build_directory$ make"
\endverbatim

Or complety out of sources :

\verbatim
"navarrop@caraja:~/Developments$ mkdir build_dir"
"navarrop@caraja:~/Developments$ cd build_dir/"
"navarrop@caraja:~/Developments/build_dir$ cmake ../simgrid/"
"navarrop@caraja:~/Developments/build_dir$ make"
\endverbatim

Those two kind of compilation permit to delete files created by compilation easier.

\subsubsection faq_cmakecompilation3 Resume of command line

 \li CMake
\verbatim
cmake <path>		configure the project
make			build all targets
make VERBOSE=1		build all targets and print build command lines
make check		test all targets and summarize
make dist		make the distrib
make distcheck		check the dist (make + make dist + make check) 
make install 		install the project (doc/ lib/ include/)
make uninstall		uninstall the project (doc/ lib/ include/)
make clean		clean all targets
make java-clean		clean files created by java option
make doc-clean		clean files created for making doc
make supernovae-clean	clean supernovae files
make maintainer-clean	clean maintainer files
make all-clean		execute the 5 upper clean command
make html		Create simgrid documentation
\endverbatim

When the project have been succesfully compiling and build you can make tests.

 \li CTest
\verbatim
ctest			launch only tests
ctest -D Continuous
ctest -D Continuous(Start|Update|Configure|Build)
ctest -D Continuous(Test|Coverage|MemCheck|Submit)
ctest -D Experimental
ctest -D Experimental(Start|Update|Configure|Build)
ctest -D Experimental(Test|Coverage|MemCheck|Submit)
ctest -D Nightly				
ctest -D Nightly(Start|Update|Configure|Build)
ctest -D Nightly(Test|Coverage|MemCheck|Submit)
ctest -D NightlyMemoryCheck
\endverbatim

If you want to test before make a commit you can simply make "ctest -D Experimental" and then you can visualize results submitted into Cdash. <a href="http://cdash.inria.fr/CDash/index.php?project=Simgrid">(Go to Cdash site)</a>.

\subsubsection faq_cmakecompilation4 Examples for different mode.

\li Mode maintainer

cmake -Denable_maintainer_mode=on ./
\verbatim 
-- lookign for config.h
with_context auto change to ucontext
GIT_DATE 	: 2010-05-04~09-59-15
GIT_VERSION 	: 53ec816
GIT_SVN_VERSION : 7669

Configuration of package `simgrid' (revision 7669) on arch (=4):
	     BUILDNAME : 	UCONTEXT
	     SITE      : 	Linux_2.6.31-21-generic_x86_64
	     Release   :	simgrid-3.4~rev7669

	 Compiler: c++ : 	/usr/bin/c++
	        version:	c++ (Ubuntu 4.4.1-4ubuntu9) 4.4.1
	 Compiler: c   :	/usr/bin/gcc
	        version:	gcc (Ubuntu 4.4.1-4ubuntu9) 4.4.1

	       CFlags  :	-I/usr/lib/ruby/1.8/x86_64-linux -I/usr/include/lua5.1 -g3
	       CPPFlags:	
	       LDFlags :	-L/usr/lib/

	Context backend:	ucontext
	Compile Gtnets : 	0
	Gtnets path    :	
	Compile Java   :   	0
	Compile Lua    :    	1
	Compile Ruby   :    	1

	Compile Smpi   :    	ON
	Maintainer mode:	ON
	Supernovae mode:	OFF
	Tracing mode   :	OFF

	Simgrid dependencies: 	-lm -lruby1.8 -module -ldl -llua5.1 -lrt
	Gras dependencies   : 	-lm -lpthread -lrt
	Smpi dependencies   : 	

	INSTALL_PREFIX: 	/usr/local

-- Configuring done
-- Generating done
-- Build files have been written to: /home/navarrop/Developments/simgrid
\endverbatim

\li Mode supernovae

cmake -Dsupernovae=on ./
\verbatim 
-- lookign for config.h
with_context auto change to ucontext
GIT_DATE 	: 2010-05-04~09-59-15
GIT_VERSION 	: 53ec816
GIT_SVN_VERSION : 7669

Configuration of package `simgrid' (revision 7669) on arch (=4):
	     BUILDNAME : 	SUPERNOVAE
	     SITE      : 	Linux_2.6.31-21-generic_x86_64
	     Release   :	simgrid-3.4~rev7669

	 Compiler: c++ : 	/usr/bin/c++
	        version:	c++ (Ubuntu 4.4.1-4ubuntu9) 4.4.1
	 Compiler: c   :	/usr/bin/gcc
	        version:	gcc (Ubuntu 4.4.1-4ubuntu9) 4.4.1

	       CFlags  :	-O3 -finline-functions -funroll-loops -fno-strict-aliasing -Wall -Wunused -Wmissing-prototypes -Wmissing-declarations -Wpointer-arith -Wchar-subscripts -Wcomment -Wformat -Wwrite-strings -Wno-unused-function -Wno-unused-parameter -Wno-strict-aliasing -Wno-format-nonliteral -Werror -I/usr/lib/ruby/1.8/x86_64-linux -I/usr/include/lua5.1 -g3
	       CPPFlags:	
	       LDFlags :	-L/usr/lib/

	Context backend:	ucontext
	Compile Gtnets : 	0
	Gtnets path    :	
	Compile Java   :   	0
	Compile Lua    :    	1
	Compile Ruby   :    	1

	Compile Smpi   :    	ON
	Maintainer mode:	OFF
	Supernovae mode:	OFF
	Tracing mode   :	OFF

	Simgrid dependencies: 	-lm -lruby1.8 -module -ldl -llua5.1 -lrt
	Gras dependencies   : 	-lm -lpthread -lrt
	Smpi dependencies   : 	

	INSTALL_PREFIX: 	/usr/local

-- Configuring done
-- Generating done
-- Build files have been written to: /home/navarrop/Developments/simgrid

\endverbatim

\li Mode GTnetS

cmake -Dgtnets_path=/home/navarrop/Bureau/usr/ ./
\verbatim 
-- lookign for config.h
with_context auto change to ucontext
GIT_DATE 	: 2010-05-04~09-59-15
GIT_VERSION 	: 53ec816
GIT_SVN_VERSION : 7669

Configuration of package `simgrid' (revision 7669) on arch (=4):
	     BUILDNAME : 	GTNETS
	     SITE      : 	Linux_2.6.31-21-generic_x86_64
	     Release   :	simgrid-3.4~rev7669

	 Compiler: c++ : 	/usr/bin/c++
	        version:	c++ (Ubuntu 4.4.1-4ubuntu9) 4.4.1
	 Compiler: c   :	/usr/bin/gcc
	        version:	gcc (Ubuntu 4.4.1-4ubuntu9) 4.4.1

	       CFlags  :	-O3 -finline-functions -funroll-loops -fno-strict-aliasing -Wall -Wunused -Wmissing-prototypes -Wmissing-declarations -Wpointer-arith -Wchar-subscripts -Wcomment -Wformat -Wwrite-strings -Wno-unused-function -Wno-unused-parameter -Wno-strict-aliasing -Wno-format-nonliteral -Werror -I/usr/lib/ruby/1.8/x86_64-linux -L/usr/lib -I/usr/include/gtnets -I/usr/include/lua5.1 -g3
	       CPPFlags:	-L/usr/lib -I/usr/include/gtnets 
	       LDFlags :	-L/usr/lib/

	Context backend:	ucontext
	Compile Gtnets : 	1
	Gtnets path    :	/usr
	Compile Java   :   	0
	Compile Lua    :    	1
	Compile Ruby   :    	1

	Compile Smpi   :    	ON
	Maintainer mode:	OFF
	Supernovae mode:	OFF
	Tracing mode   :	OFF

	Simgrid dependencies: 	-lm -lruby1.8 -module -ldl -llua5.1 -lgtnets -lrt
	Gras dependencies   : 	-lm -lpthread -lrt
	Smpi dependencies   : 	

	INSTALL_PREFIX: 	/usr/local

-- Configuring done
-- Generating done
-- Build files have been written to: /home/navarrop/Developments/simgrid

\endverbatim

\subsection faq_cmakeinstall How to install with cmake?

\subsubsection faq_cmakeinstall1 From svn. 

\verbatim
cmake -Denable_maintainer_mode=on -Dprefix=/home/navarrop/Bureau/install_simgrid ./
make 
make install
\endverbatim

\subsubsection faq_cmakeinstall2 From a distrib

\verbatim
cmake -Dprefix=/home/navarrop/Bureau/install_simgrid ./
make
make install
\endverbatim

\subsection faq_cmakehowto How to modified sources files for developers

\subsubsection faq_cmakehowto1 Add an executable or examples.

If you want make an executable you have to create a CMakeList.txt to the src directory. 
You must specified where to create the executable, source list, dependencies and the name of the binary.

\verbatim
cmake_minimum_required(VERSION 2.6)

set(EXECUTABLE_OUTPUT_PATH "./")			
set(LIBRARY_OUTPUT_PATH "${PROJECT_DIRECTORY}/lib")

add_executable(get_sender get_sender.c)					#add_executable(<name_of_target> <src list>)

### Add definitions for compile
target_link_libraries(get_sender simgrid m pthread -fprofile-arcs) 	#target_link_libraries(<name_of_targe> <dependencies>)
\endverbatim

Then you have to modified <project/directory>/buildtools/Cmake/CMakeMakeExeLib.txt and add 
this line :
\verbatim
add_subdirectory(${PROJECT_DIRECTORY}/<path_where_is_CMakeList.txt>)
\endverbatim

\subsubsection faq_cmakehowto2 Delete/add sources to lib.

If you want modified, add or delete source files from a library you have to edit <project/directory>/buildtools/Cmake/CMakeDefinePackages.txt

\verbatim
set(JMSG_JAVA_SRC
	${PROJECT_DIRECTORY}/src/java/simgrid/msg/MsgException.java
	${PROJECT_DIRECTORY}/src/java/simgrid/msg/JniException.java
	${PROJECT_DIRECTORY}/src/java/simgrid/msg/NativeException.java
	${PROJECT_DIRECTORY}/src/java/simgrid/msg/HostNotFoundException.java
	${PROJECT_DIRECTORY}/src/java/simgrid/msg/ProcessNotFoundException.java
	${PROJECT_DIRECTORY}/src/java/simgrid/msg/Msg.java
	${PROJECT_DIRECTORY}/src/java/simgrid/msg/Process.java
	${PROJECT_DIRECTORY}/src/java/simgrid/msg/Host.java
	${PROJECT_DIRECTORY}/src/java/simgrid/msg/Task.java
	${PROJECT_DIRECTORY}/src/java/simgrid/msg/MsgNative.java
	${PROJECT_DIRECTORY}/src/java/simgrid/msg/ApplicationHandler.java
	${PROJECT_DIRECTORY}/src/java/simgrid/msg/Sem.java
)
\endverbatim

\subsubsection faq_cmakehowto3 Add test

If you want modified, add or delete tests you have to edit <project/directory>/buildtools/Cmake/CMakeTest.txt 
with this function : ADD_TEST(<name> <bin> <ARGS>)

\verbatim
add_test(test-simdag-1 ${PROJECT_DIRECTORY}/testsuite/simdag/sd_test --cfg=path:${PROJECT_DIRECTORY}/testsuite/simdag small_platform_variable.xml)
\endverbatim

\subsection faq_cmakeExplain Explaination of sources files for cmake

\li CMakeLists.txt

Those files are the "main parts". One located at the project directory call all the cmake sources files. The others
are little projects called by the first for make examples.

\li CMakeCompleteInFiles.txt

Complete all .in files and define Variables for h files

\li CMakeDocs.txt

This file make the html documentation.

\li CMakeMakeExeLib.txt

Here are callled all "CMakeLists.txt" for make executables and libraries.

\li CMakePrintArgs.txt

This file is called at the end of the build for summarize environment variables.

\li CMakeDefinePackages.txt

Here is defined sources packages for compiling libs.

\li CMakeFlags.txt

Defined flags which are used for compiling sources.

\li CMakeSupernovae.txt

Here are made files for the supernovae mode.

\li CMakeDistrib.txt

Here is defined packages for install simgrid and make a distribution.

\li CMakeMaintainerMode.txt

Part where are generated source files for maintainer mode.

\li CMakeOption.txt

Here are defined options and initialized values.

\li CMakeTest.txt

All tests are listed.

\li CTestConfig.cmake

Properties which link tests with dashboard.

\subsection faq_cmakeList List of files added for cmake

Here is a list of files involved into cmake build (relative to project directory path) :
\verbatim

Cmake sources:
	./doc/CMakeLists.txt
	./buildtools/Cmake/AddTests.cmake
	./buildtools/Cmake/CompleteInFiles.cmake
	./buildtools/Cmake/CTestConfig.cmake
	./buildtools/Cmake/DefinePackages.cmake
	./buildtools/Cmake/Distrib.cmake
	./buildtools/Cmake/Flags.cmake
	./buildtools/Cmake/GenerateDocs.cmake
	./buildtools/Cmake/MaintainerMode.cmake
	./buildtools/Cmake/MakeExeLib.cmake
	./buildtools/Cmake/MakeJava.cmake
	./buildtools/Cmake/Option.cmake
	./buildtools/Cmake/PrintArgs.cmake
	./buildtools/Cmake/Supernovae.cmake
	
CMakeLists for each binaries or examples:
	./CMakeLists.txt
	./src/CMakeLists.txt
	./teshsuite/gras/empty_main/CMakeLists.txt
	./teshsuite/gras/small_sleep/CMakeLists.txt
	./teshsuite/gras/datadesc/CMakeLists.txt
	./teshsuite/gras/msg_handle/CMakeLists.txt
	./teshsuite/simdag/CMakeLists.txt
	./teshsuite/simdag/partask/CMakeLists.txt
	./teshsuite/simdag/platforms/CMakeLists.txt
	./teshsuite/simdag/network/CMakeLists.txt
	./teshsuite/simdag/network/mxn/CMakeLists.txt
	./teshsuite/simdag/network/p2p/CMakeLists.txt
	./teshsuite/xbt/CMakeLists.txt
	./teshsuite/msg/CMakeLists.txt
	./tools/gras/CMakeLists.txt
	./tools/tesh/CMakeLists.txt
	./testsuite/simdag/CMakeLists.txt
	./testsuite/xbt/CMakeLists.txt
	./testsuite/surf/CMakeLists.txt
	./examples/gras/properties/CMakeLists.txt
	./examples/gras/ping/CMakeLists.txt
	./examples/gras/pmm/CMakeLists.txt
	./examples/gras/mmrpc/CMakeLists.txt
	./examples/gras/synchro/CMakeLists.txt
	./examples/gras/timer/CMakeLists.txt
	./examples/gras/mutual_exclusion/simple_token/CMakeLists.txt
	./examples/gras/spawn/CMakeLists.txt
	./examples/gras/chrono/CMakeLists.txt
	./examples/gras/rpc/CMakeLists.txt
	./examples/gras/all2all/CMakeLists.txt
	./examples/simdag/properties/CMakeLists.txt
	./examples/simdag/CMakeLists.txt
	./examples/simdag/metaxml/CMakeLists.txt
	./examples/simdag/dax/CMakeLists.txt
	./examples/smpi/CMakeLists.txt
	./examples/amok/bandwidth/CMakeLists.txt
	./examples/amok/saturate/CMakeLists.txt
	./examples/msg/priority/CMakeLists.txt
	./examples/msg/properties/CMakeLists.txt
	./examples/msg/migration/CMakeLists.txt
	./examples/msg/gtnets/CMakeLists.txt
	./examples/msg/parallel_task/CMakeLists.txt
	./examples/msg/trace/CMakeLists.txt
	./examples/msg/suspend/CMakeLists.txt
	./examples/msg/masterslave/CMakeLists.txt
	./examples/msg/actions/CMakeLists.txt
	./examples/msg/sendrecv/CMakeLists.txt
\endverbatim

\section faq_howto Feature related questions

\subsection faq_MIA "Could you please add (your favorite feature here) to SimGrid?"

Here is the deal. The whole SimGrid project (MSG, SURF, GRAS, ...) is
meant to be kept as simple and generic as possible. We cannot add
functions for everybody's needs when these functions can easily be
built from the ones already in the API. Most of the time, it is
possible and when it was not possible we always have upgraded the API
accordingly. When somebody asks us a question like "How to do that?
Is there a function in the API to simply do this?", we're always glad
to answer and help. However if we don't need this code for our own
need, there is no chance we're going to write it... it's your job! :)
The counterpart to our answers is that once you come up with a neat
implementation of this feature (task duplication, RPC, thread
synchronization, ...), you should send it to us and we will be glad to
add it to the distribution. Thus, other people will take advantage of
it (and we don't have to answer this question again and again ;).

You'll find in this section a few "Missing In Action" features. Many
people have asked about it and we have given hints on how to simply do
it with MSG. Feel free to contribute...

\subsection faq_MIA_MSG MSG features

\subsubsection faq_MIA_examples I want some more complex MSG examples!

Many people have come to ask me a more complex example and each time,
they have realized afterward that the basics were in the previous three
examples. 

Of course they have often been needing more complex functions like
MSG_process_suspend(), MSG_process_resume() and
MSG_process_isSuspended() (to perform synchronization), or
MSG_task_Iprobe() and MSG_process_sleep() (to avoid blocking
receptions), or even MSG_process_create() (to design asynchronous
communications or computations). But the examples are sufficient to
start.

We know. We should add some more examples, but not really some more
complex ones... We should add some examples that illustrate some other
functionalists (like how to simply encode asynchronous
communications, RPC, process migrations, thread synchronization, ...)
and we will do it when we will have a little bit more time. We have
tried to document the examples so that they are understandable. Tell
us if something is not clear and once again feel free to participate!
:)

\subsubsection faq_MIA_taskdup Missing in action: MSG Task duplication/replication

There is no task duplication in MSG. When you create a task, you can
process it or send it somewhere else. As soon as a process has sent
this task, he doesn't have this task anymore. It's gone. The receiver
process has got the task. However, you could decide upon receiving to
create a "copy" of a task but you have to handle by yourself the
semantic associated to this "duplication".

As we already told, we prefer keeping the API as simple as
possible. This kind of feature is rather easy to implement by users
and the semantic you associate really depends on people. Having a
*generic* task duplication mechanism is not that trivial (in
particular because of the data field). That is why I would recommand
that you write it by yourself even if I can give you advice on how to
do it.

You have the following functions to get informations about a task:
MSG_task_get_name(), MSG_task_get_compute_duration(),
MSG_task_get_remaining_computation(), MSG_task_get_data_size(),
and MSG_task_get_data().

You could use a dictionary (#xbt_dict_t) of dynars (#xbt_dynar_t). If
you still don't see how to do it, please come back to us...

\subsubsection faq_MIA_asynchronous I want to do asynchronous communications in MSG

Up until now, there is no asynchronous communications in MSG. However,
you can create as many process as you want so you should be able to do
whatever you want... I've written a queue module to help implementing
some asynchronous communications at low cost (creating thousands of
process only to handle communications may be problematic in term of
performance at some point). I'll add it in the distribution asap.

\subsubsection faq_MIA_thread_synchronization I need to synchronize my MSG processes

You obviously cannot use pthread_mutexes of pthread_conds. The best
thing would be to propose similar structures. Unfortunately, we
haven't found time to do it yet. However you can try to play with
MSG_process_suspend() and MSG_process_resume(). You can even do some
synchronization with fake communications (using MSG_task_get(),
MSG_task_put() and MSG_task_Iprobe()).

\subsubsection faq_MIA_host_load Where is the get_host_load function hidden in MSG?

There is no such thing because its semantic wouldn't be really
clear. Of course, it is something about the amount of host throughput,
but there is as many definition of "host load" as people asking for
this function. First, you have to remember that resource availability
may vary over time, which make any load notion harder to define.

It may be instantaneous value or an average one. Moreover it may be only the
power of the computer, or may take the background load into account, or may
even take the currently running tasks into account. In some SURF models,
communications have an influence on computational power. Should it be taken
into account too?

First of all, it's near to impossible to predict the load beforehands in the
simulator since it depends on too much parameters (background load
variation, bandwidth sharing algorithmic complexity) some of them even being
not known beforehands (other task starting at the same time). So, getting
this information is really hard (just like in real life). It's not just that
we want MSG to be as painful as real life. But as it is in some way
realistic, we face some of the same problems as we would face in real life.

How would you do it for real? The most common option is to use something
like NWS that performs active probes. The best solution is probably to do
the same within MSG, as in next code snippet. It is very close from what you
would have to do out of the simulator, and thus gives you information that
you could also get in real settings to not hinder the realism of your
simulation. 

\verbatim
double get_host_load() {
   m_task_t task = MSG_task_create("test", 0.001, 0, NULL);
   double date = MSG_get_clock();

   MSG_task_execute(task);
   date = MSG_get_clock() - date;
   MSG_task_destroy(task);
   return (0.001/date);
}
\endverbatim

Of course, it may not match your personal definition of "host load". In this
case, please detail what you mean on the mailing list, and we will extend
this FAQ section to fit your taste if possible.

\subsubsection faq_MIA_communication_time How can I get the *real* communication time?  

Communications are synchronous and thus if you simply get the time
before and after a communication, you'll only get the transmission
time and the time spent to really communicate (it will also take into
account the time spent waiting for the other party to be
ready). However, getting the *real* communication time is not really
hard either. The following solution is a good starting point.

\verbatim
int sender()
{
  m_task_t task = MSG_task_create("Task", task_comp_size, task_comm_size, 
                                  calloc(1,sizeof(double)));
  *((double*) task->data) = MSG_get_clock();
  MSG_task_put(task, slaves[i % slaves_count], PORT_22);
  INFO0("Send completed");
  return 0;
}
int receiver()
{
  m_task_t task = NULL;
  double time1,time2;

  time1 = MSG_get_clock();
  a = MSG_task_get(&(task), PORT_22);
  time2 = MSG_get_clock();
  if(time1<*((double *)task->data))
     time1 = *((double *) task->data);
  INFO1("Communication time :  \"%f\" ", time2-time1);
  free(task->data);
  MSG_task_destroy(task);
  return 0;
}
\endverbatim

\subsection faq_MIA_SimDag SimDag related questions

\subsubsection faq_SG_comm Implementing communication delays between tasks.

A classic question of SimDag newcomers is about how to express a
communication delay between tasks. The thing is that in SimDag, both
computation and communication are seen as tasks.  So, if you want to
model a data dependency between two DAG tasks t1 and t2, you have to
create 3 SD_tasks: t1, t2 and c and add dependencies in the following
way:

\verbatim
SD_task_dependency_add(NULL, NULL, t1, c);
SD_task_dependency_add(NULL, NULL, c, t2);
\endverbatim

This way task t2 cannot start before the termination of communication c
which in turn cannot start before t1 ends.

When creating task c, you have to associate an amount of data (in bytes)
corresponding to what has to be sent by t1 to t2.

Finally to schedule the communication task c, you have to build a list
comprising the workstations on which t1 and t2 are scheduled (w1 and w2
for example) and build a communication matrix that should look like
[0;amount ; 0; 0].

\subsubsection faq_SG_DAG How to implement a distributed dynamic scheduler of DAGs.

Distributed is somehow "contagious". If you start making distributed
decisions, there is no way to handle DAGs directly anymore (unless I
am missing something). You have to encode your DAGs in term of
communicating process to make the whole scheduling process
distributed. Here is an example of how you could do that. Assume T1
has to be done before T2.

\verbatim
 int your_agent(int argc, char *argv[] {
   ...
   T1 = MSG_task_create(...);
   T2 = MSG_task_create(...);
   ...
   while(1) {
     ...
     if(cond) MSG_task_execute(T1);
     ...
     if((MSG_task_get_remaining_computation(T1)=0.0) && (you_re_in_a_good_mood))
        MSG_task_execute(T2)
     else {
        /* do something else */
     }
   }
 }
\endverbatim
 
If you decide that the distributed part is not that much important and that
DAG is really the level of abstraction you want to work with, then you should
give a try to \ref SD_API.

\subsection faq_MIA_generic Generic features

\subsubsection faq_more_processes Increasing the amount of simulated processes

Here are a few tricks you can apply if you want to increase the amount
of processes in your simulations.

 - <b>A few thousands of simulated processes</b> (soft tricks)\n
   SimGrid can use either pthreads library or the UNIX98 contextes. On
   most systems, the number of pthreads is limited and then your
   simulation may be limited for a stupid reason. This is especially
   true with the current linux pthreads, and I cannot get more than
   2000 simulated processes with pthreads on my box. The UNIX98
   contexts allow me to raise the limit to 25,000 simulated processes
   on my laptop.\n\n
   The <tt>--with-context</tt> option of the <tt>./configure</tt>
   script allows you to choose between UNIX98 contextes
   (<tt>--with-context=ucontext</tt>) and the pthread version
   (<tt>--with-context=pthread</tt>). The default value is ucontext
   when the script detect a working UNIX98 context implementation. On
   Windows boxes, the provided value is discarded and an adapted
   version is picked up.\n\n
   We experienced some issues with contextes on some rare systems
   (solaris 8 and lower or old alpha linuxes comes to mind). The main
   problem is that the configure script detect the contextes as being
   functional when it's not true. If you happen to use such a system,
   switch manually to the pthread version, and provide us with a good
   patch for the configure script so that it is done automatically ;)

 - <b>Hundred thousands of simulated processes</b> (hard-core tricks)\n 
   As explained above, SimGrid can use UNIX98 contextes to represent
   and handle the simulated processes. Thanks to this, the main
   limitation to the number of simulated processes becomes the
   available memory.\n\n
   Here are some tricks I had to use in order to run a token ring
   between 25,000 processes on my laptop (1Gb memory, 1.5Gb swap).\n
   - First of all, make sure your code runs for a few hundreds
     processes before trying to push the limit. Make sure it's
     valgrind-clean, ie that valgrind does not report neither memory
     error nor memory leaks. Indeed, numerous simulated processes
     result in *fat* simulation hindering debugging.
   - It was really boring to write 25,000 entries in the deployment
     file, so I wrote a little script
     <tt>examples/gras/mutual_exclusion/simple_token/make_deployment.pl</tt>, which you may
     want to adapt to your case. You could also think about hijacking
     the SURFXML parser (have look at \ref faq_flexml_bypassing).
   - The deployment file became quite big, so I had to do what is in
     the FAQ entry \ref faq_flexml_limit
   - Each UNIX98 context has its own stack entry. As debugging this is
     quite hairly, the default value is a bit overestimated so that
     user don't get into trouble about this. You want to tune this
     size to increse the number of processes. This is the
     <tt>STACK_SIZE</tt> define in 
     <tt>src/xbt/xbt_context_sysv.c</tt>, which is 128kb by default.
     Reduce this as much as you can, but be warned that if this value
     is too low, you'll get a segfault. The token ring example, which
     is quite simple, runs with 40kb stacks.     
   - You may tweak the logs to reduce the stack size further.  When
     logging something, we try to build the string to display in a
     char array on the stack. The size of this array is constant (and
     equal to XBT_LOG_BUFF_SIZE, defined in include/xbt/log/h). If the
     string is too large to fit this buffer, we move to a dynamically
     sized buffer. In which case, we have to traverse one time the log
     event arguments to compute the size we need for the buffer,
     malloc it, and traverse the argument list again to do the actual
     job.\n     
     The idea here is to move XBT_LOG_BUFF_SIZE to 1, forcing the logs
     to use a dynamic array each time. This allows us to lower further
     the stack size at the price of some performance loss...\n
     This allowed me to run the reduce the stack size to ... 4k. Ie,
     on my 1Gb laptop, I can run more than 250,000 processes!

\subsubsection faq_MIA_batch_scheduler Is there a native support for batch schedulers in SimGrid?

No, there is no native support for batch schedulers and none is
planned because this is a very specific need (and doing it in a
generic way is thus very hard). However some people have implemented
their own batch schedulers. Vincent Garonne wrote one during his PhD
and put his code in the contrib directory of our SVN so that other can
keep working on it. You may find inspiring ideas in it.

\subsubsection faq_MIA_checkpointing I need a checkpointing thing

Actually, it depends on whether you want to checkpoint the simulation, or to
simulate checkpoints. 

The first one could help if your simulation is a long standing process you
want to keep running even on hardware issues. It could also help to
<i>rewind</i> the simulation by jumping sometimes on an old checkpoint to
cancel recent calculations.\n 
Unfortunately, such thing will probably never exist in SG. One would have to
duplicate all data structures because doing a rewind at the simulator level
is very very hard (not talking about the malloc free operations that might
have been done in between). Instead, you may be interested in the Libckpt
library (http://www.cs.utk.edu/~plank/plank/www/libckpt.html). This is the
checkpointing solution used in the condor project, for example. It makes it
easy to create checkpoints (at the OS level, creating something like core
files), and rerunning them on need.

If you want to simulate checkpoints instead, it means that you want the
state of an executing task (in particular, the progress made towards
completion) to be saved somewhere.  So if a host (and the task executing on
it) fails (cf. #MSG_HOST_FAILURE), then the task can be restarted
from the last checkpoint.\n

Actually, such a thing does not exists in SimGrid either, but it's just
because we don't think it is fundamental and it may be done in the user code
at relatively low cost. You could for example use a watcher that
periodically get the remaining amount of things to do (using
MSG_task_get_remaining_computation()), or fragment the task in smaller
subtasks.

\subsection faq_platform Platform building and Dynamic resources

\subsubsection faq_platform_example Where can I find SimGrid platform files?

There is several little examples in the archive, in the examples/msg
directory. From time to time, we are asked for other files, but we
don't have much at hand right now. 

You should refer to the Platform Description Archive
(http://pda.gforge.inria.fr) project to see the other platform file we
have available, as well as the Simulacrum simulator, meant to generate
SimGrid platforms using all classical generation algorithms.

\subsubsection faq_platform_alnem How can I automatically map an existing platform?

We are working on a project called ALNeM (Application-Level Network
Mapper) which goal is to automatically discover the topology of an
existing network. Its output will be a platform description file
following the SimGrid syntax, so everybody will get the ability to map
their own lab network (and contribute them to the catalog project).
This tool is not ready yet, but it move quite fast forward. Just stay
tuned.

\subsubsection faq_platform_synthetic Generating synthetic but realistic platforms

The third possibility to get a platform file (after manual or
automatic mapping of real platforms) is to generate synthetic
platforms. Getting a realistic result is not a trivial task, and
moreover, nobody is really able to define what "realistic" means when
speaking of topology files. You can find some more thoughts on this
topic in these
<a href="http://graal.ens-lyon.fr/~alegrand/articles/Simgrid-Introduction.pdf">slides</a>.

If you are looking for an actual tool, there we have a little tool to
annotate Tiers-generated topologies. This perl-script is in
<tt>tools/platform_generation/</tt> directory of the SVN. Dinda et Al.
released a very comparable tool, and called it GridG.

\subsubsection faq_SURF_dynamic Expressing dynamic resource availability in platform files

A nice feature of SimGrid is that it enables you to seamlessly have
resources whose availability change over time. When you build a
platform, you generally declare hosts like that:

\verbatim
  <host id="host A" power="100.00"/>
\endverbatim 

If you want the availability of "host A" to change over time, the only
thing you have to do is change this definition like that:

\verbatim
  <host id="host A" power="100.00" availability_file="trace_A.txt" state_file="trace_A_failure.txt"/>
\endverbatim

For hosts, availability files are expressed in fraction of available
power. Let's have a look at what "trace_A.txt" may look like:

\verbatim
PERIODICITY 1.0
0.0 1.0
11.0 0.5
20.0 0.9
\endverbatim

At time 0, our host will deliver 100 flop/s. At time 11.0, it will
deliver only 50 flop/s until time 20.0 where it will will start
delivering 90 flop/s. Last at time 21.0 (20.0 plus the periodicity
1.0), we'll be back to the beginning and it will deliver 100 flop/s.

Now let's look at the state file:
\verbatim
PERIODICITY 10.0
1.0 -1.0
2.0 1.0
\endverbatim

A negative value means "off" while a positive one means "on". At time
1.0, the host is on. At time 1.0, it is turned off and at time 2.0, it
is turned on again until time 12 (2.0 plus the periodicity 10.0). It
will be turned on again at time 13.0 until time 23.0, and so on.

Now, let's look how the same kind of thing can be done for network
links. A usual declaration looks like:

\verbatim
  <link id="LinkA" bandwidth="10.0" latency="0.2"/>
\endverbatim

You have at your disposal the following options: bandwidth_file,
latency_file and state_file. The only difference with hosts is that
bandwidth_file and latency_file do not express fraction of available
power but are expressed directly in bytes per seconds and seconds.

\subsubsection faq_platform_multipath How to express multipath routing in platform files?

It is unfortunately impossible to express the fact that there is more
than one routing path between two given hosts. Let's consider the
following platform file:

\verbatim
<route src="A" dst="B">
   <link:ctn id="1"/>
</route>
<route src="B" dst="C">
  <link:ctn id="2"/>
</route>
<route src="A" dst="C">
  <link:ctn id="3"/>
</route>
\endverbatim

Although it is perfectly valid, it does not mean that data traveling
from A to C can either go directly (using link 3) or through B (using
links 1 and 2). It simply means that the routing on the graph is not
trivial, and that data do not following the shortest path in number of
hops on this graph. Another way to say it is that there is no implicit
in these routing descriptions. The system will only use the routes you
declare (such as &lt;route src="A" dst="C"&gt;&lt;link:ctn
id="3"/&gt;&lt;/route&gt;), without trying to build new routes by aggregating
the provided ones.
  
You are also free to declare platform where the routing is not
symmetric. For example, add the following to the previous file:

\verbatim
<route src="C" dst="A">
  <link:ctn id="2"/>
  <link:ctn id="1"/>
</route>
\endverbatim

This makes sure that data from C to A go through B where data from A
to C go directly. Don't worry about realism of such settings since
we've seen ways more weird situation in real settings (in fact, that's
the realism of very regular platforms which is questionable, but
that's another story).

\subsubsection faq_flexml_bypassing Bypassing the XML parser with your own C functions

So you want to bypass the XML files parser, uh? Maybe doing some parameter
sweep experiments on your simulations or so? This is possible, and
it's not even really difficult (well. Such a brutal idea could be
harder to implement). Here is how it goes.

For this, you have to first remember that the XML parsing in SimGrid is done
using a tool called FleXML. Given a DTD, this gives a flex-based parser. If
you want to bypass the parser, you need to provide some code mimicking what
it does and replacing it in its interactions with the SURF code. So, let's
have a look at these interactions.

FleXML parser are close to classical SAX parsers. It means that a
well-formed SimGrid platform XML file might result in the following
"events":

  - start "platform_description" with attribute version="2"
  - start "host" with attributes id="host1" power="1.0"
  - end "host"
  - start "host" with attributes id="host2" power="2.0"
  - end "host"
  - start "link" with ...
  - end "link"
  - start "route" with ...
  - start "link:ctn" with ...
  - end "link:ctn"
  - end "route"
  - end "platform_description"

The communication from the parser to the SURF code uses two means:
Attributes get copied into some global variables, and a surf-provided
function gets called by the parser for each event. For example, the event
  - start "host" with attributes id="host1" power="1.0"

let the parser do something roughly equivalent to:
\verbatim
  strcpy(A_host_id,"host1");
  A_host_power = 1.0;
  STag_host();
\endverbatim

In SURF, we attach callbacks to the different events by initializing the
pointer functions to some the right surf functions. Since there can be
more than one callback attached to the same event (if more than one
model is in use, for example), they are stored in a dynar. Example in
workstation_ptask_L07.c:
\verbatim
  /* Adding callback functions */
  surf_parse_reset_parser();
  surfxml_add_callback(STag_surfxml_host_cb_list, &parse_cpu_init);
  surfxml_add_callback(STag_surfxml_prop_cb_list, &parse_properties);
  surfxml_add_callback(STag_surfxml_link_cb_list, &parse_link_init);
  surfxml_add_callback(STag_surfxml_route_cb_list, &parse_route_set_endpoints);
  surfxml_add_callback(ETag_surfxml_link_c_ctn_cb_list, &parse_route_elem);
  surfxml_add_callback(ETag_surfxml_route_cb_list, &parse_route_set_route);
                
  /* Parse the file */
  surf_parse_open(file);
  xbt_assert1((!surf_parse()), "Parse error in %s", file);
  surf_parse_close();
\endverbatim
    
So, to bypass the FleXML parser, you need to write your own version of the
surf_parse function, which should do the following:
   - Fill the A_<tag>_<attribute> variables with the wanted values
   - Call the corresponding STag_<tag>_fun function to simulate tag start
   - Call the corresponding ETag_<tag>_fun function to simulate tag end
   - (do the same for the next set of values, and loop)

Then, tell SimGrid that you want to use your own "parser" instead of the stock one:
\verbatim
  surf_parse = surf_parse_bypass_environment;
  MSG_create_environment(NULL);
  surf_parse = surf_parse_bypass_application;
  MSG_launch_application(NULL);
\endverbatim

A set of macros are provided at the end of
include/surf/surfxml_parse.h to ease the writing of the bypass
functions. An example of this trick is distributed in the file
examples/msg/masterslave/masterslave_bypass.c

\subsection faq_simgrid_configuration Changing SimGrid's behavior

A number of options can be given at runtime to change the default
SimGrid behavior. In particular, you can change the default cpu and
network models...

\subsubsection faq_simgrid_configuration_gtnets Using GTNetS

It is possible to use a packet-level network simulator
instead of the default flow-based simulation. You may want to use such
an approach if you have doubts about the validity of the default model
or if you want to perform some validation experiments. At the moment,
we support the GTNetS simulator (it is still rather experimental
though, so leave us a message if you play with it). 


<i>
To enable GTNetS model inside SimGrid it is needed to patch the GTNetS simulator source code 
and build/install it from scratch
</i>

 - <b>Download and enter the recent downloaded GTNetS directory</b>

 \verbatim
 svn checkout svn://scm.gforge.inria.fr/svn/simgrid/contrib/trunk/GTNetS/
 cd GTNetS
 \endverbatim


 - <b>Use the following commands to unzip and patch GTNetS package to work within SimGrid.</b>

 \verbatim
 unzip gtnets-current.zip
 tar zxvf gtnets-current-patch.tgz 
 cd gtnets-current
 cat ../00*.patch | patch -p1
 \endverbatim

  - <b>OPTIONALLY</b> you can use a patch for itanium 64bit processor family.

  \verbatim
  cat ../AMD64-FATAL-Removed-DUL_SIZE_DIFF-Added-fPIC-compillin.patch | patch -p1
  \endverbatim

 - <b>Compile GTNetS</b>

   Due to portability issues it is possible that GTNetS does not compile in your architecture. The patches furnished in SimGrid SVN repository are intended for use in Linux architecture only. Unfortunately, we do not have the time, the money, neither the manpower to guarantee GTNetS portability. We advice you to use one of GTNetS communication channel to get more help in compiling GTNetS. 


 \verbatim
 ln -sf Makefile.linux Makefile
 make depend
 make debug
 \endverbatim


 - <b>NOTE</b> A lot of warnings are expected but the application should compile
 just fine. If the makefile insists in compiling some QT libraries
 please try a make clean before asking for help.


 - <b>To compile optimized version</b>

 \verbatim
 make opt
 \endverbatim


 - <b>Installing GTNetS</b>

 It is important to put the full path of your libgtsim-xxxx.so file when creating the symbolic link. Replace < userhome > by some path you have write access to.

 \verbatim
 ln -sf /<absolute_path>/gtnets_current/libgtsim-debug.so /<userhome>/usr/lib/libgtnets.so
 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/<userhome>/usr/lib/libgtnets.so
 mkdir /<userhome>/usr/include/gtnets
 cp -fr SRC/*.h /<userhome>/usr/include/gtnets
 \endverbatim


 - <b>Enable GTNetS support in SimGrid</b>

   \verbatim
   ./configure --with-gtnets=/<userhome>/usr
   \endverbatim

 - <b>Once you have followed all the instructions for compiling and
   installing successfully you can activate this feature at 
   runntime with the following options:</b>

   \verbatim
   cd simgrid/example/msg/
   make
   make check
   \endverbatim


 - <b>Or try the GTNetS model dogbone example with</b>

 \verbatim
 gtnets/gtnets gtnets/onelink-p.xml gtnets/onelink-d.xml --cfg=network_model:GTNets
 \endverbatim

 
 A long version of this <a href="http://gforge.inria.fr/docman/view.php/12/6283/GTNetS HowTo.html">HowTo</a>  it is available 


 More about GTNetS simulator at <a href="http://www.ece.gatech.edu/research/labs/MANIACS/GTNetS/index.html">GTNetS Website</a>


 - <b>DISCLAIMER</b>
 The patches provided by us worked successfully with GTNetS found 
 <a href="http://www.ece.gatech.edu/research/labs/MANIACS/GTNetS/software/gtnets-current.zip">here</a>, 
 dated from 12th June 2008. Due to the discontinuing development of
 GTNetS it is impossible to precise a version number. We STRONGLY recommend you
 to download and install the GTNetS version found in SimGrid repository as explained above.
 



\subsubsection faq_simgrid_configuration_alternate_network Using alternative flow models

The default simgrid network model uses a max-min based approach as
explained in the research report
<a href="ftp://ftp.ens-lyon.fr/pub/LIP/Rapports/RR/RR2002/RR2002-40.ps.gz">A Network Model for Simulation of Grid Application</a>.
Other models have been proposed and implemented since then (see for example 
<a href="http://mescal.imag.fr/membres/arnaud.legrand/articles/simutools09.pdf">Accuracy Study and Improvement of Network Simulation in the SimGrid Framework</a>)
and can be activated at runtime. For example:
\verbatim
./mycode platform.xml deployment.xml --cfg=workstation/model:compound --cfg=network/model:LV08 -cfg=cpu/model:Cas01
\endverbatim

Possible models for the network are currently "Constant", "CM02",
"LegrandVelho", "GTNets", Reno", "Reno2", "Vegas". Others will
probably be added in the future and many of the previous ones are
experimental and are likely to disappear without notice... To know the
list of the currently  implemented models, you should use the
--help-models command line option.

\verbatim
./masterslave_forwarder ../small_platform.xml deployment_masterslave.xml  --help-models
Long description of the workstation models accepted by this simulator:
  CLM03: Default workstation model, using LV08 and CM02 as network and CPU
  compound: Workstation model allowing you to use other network and CPU models
  ptask_L07: Workstation model with better parallel task modeling
Long description of the CPU models accepted by this simulator:
  Cas01_fullupdate: CPU classical model time=size/power
  Cas01: Variation of Cas01_fullupdate with partial invalidation optimization of lmm system. Should produce the same values, only faster
  CpuTI: Variation of Cas01 with also trace integration. Should produce the same values, only faster if you use availability traces
Long description of the network models accepted by this simulator:
  Constant: Simplistic network model where all communication take a constant time (one second)
  CM02: Realistic network model with lmm_solve and no correction factors
  LV08: Realistic network model with lmm_solve and these correction factors: latency*=10.4, bandwidth*=.92, S=8775
  Reno: Model using lagrange_solve instead of lmm_solve (experts only)
  Reno2: Model using lagrange_solve instead of lmm_solve (experts only)
  Vegas: Model using lagrange_solve instead of lmm_solve (experts only)
\endverbatim

\subsection faq_tracing Tracing Simulations for Visualization

The trace visualization is widely used to observe and understand the behavior
of parallel applications and distributed algorithms. Usually, this is done in a
two-step fashion: the user instruments the application and the traces are
analyzed after the end of the execution. The visualization itself can highlights
unexpected behaviors, bottlenecks and sometimes can be used to correct
distributed algorithms. The SimGrid team is currently instrumenting the library
in order to let users trace their simulations and analyze them. This part of the
user manual explains how the tracing-related features can be enabled and used
during the development of simulators using the SimGrid library.

\subsubsection faq_tracing_howitworks How it works

For now, the SimGrid library is instrumented so users can trace the <b>platform
utilization</b> using the MSG interface. This means that the tracing will
register how much power is used for each host and how much bandwidth is used for
each link of the platform. The idea with this type of tracing is to observe the
overall view of resources utilization in the first place, especially the
identification of bottlenecks, load-balancing among hosts, and so on.

The idea of the instrumentation is to classify the MSG tasks by category,
and trace
the platform utilization (hosts and links) for each of the categories. For that,
the tracing interface enables the declaration of categories and a function to
mark a task with a previously declared category. <em>The tasks that are not
classified according to a category are not traced</em>.

\subsubsection faq_tracing_enabling Enabling using CMake

With the sources of SimGrid, it is possible to enable the tracing 
using the parameter <b>-Dtracing=on</b> when the cmake is executed.
The section \ref faq_tracing_functions describes all the functions available
when this Cmake options is activated. These functions will have no effect
if SimGrid is configured without this option (they are wiped-out by the
C-preprocessor).

\verbatim
$ cmake -Dtracing=on .
$ make
\endverbatim

\subsubsection faq_tracing_functions Tracing Functions

\subsubsubsection Mandatory Functions

\li <b>\c TRACE_start (const char *filename)</b>: This is the first function to
be called. It receives a single argument as parameter that contains the name of
the file that will hold the trace in the end of the simulation. It returns 0 if
everything was properly initialized, 1 otherwise. All trace functions called
before TRACE_start do nothing.

\li <b>\c TRACE_category (const char *category)</b>: This function should be used
to define a user category. The category can be used to differentiate the tasks
that are created during the simulation (for example, tasks from server1,
server2, or request tasks, computation tasks, communication tasks).
All resource utilization (host power and link bandwidth) will be
classified according to the task category. Tasks that do not belong to a
category are not traced.

\li <b>\c TRACE_msg_set_task_category (m_task_t task, const char *category)</b>:
This function should be called after the creation of a task, to define the
category of that task. The first parameter \c task must contain a task that was
created with the function \c MSG_task_create. The second parameter
\c category must contain a category that was previously defined by the function
\c TRACE_category.

\li <b>\c TRACE_end ()</b>: This is the last function to be called. It closes
the trace file and stops the tracing of the simulation. All tracing will be
completely disabled after the calling this function. Although we recommend
the use of this function somewhere in the end of program, it can be used
anywhere in the code. This function returns 0 if everything is ok, 1 otherwise.

\subsubsubsection Optional Functions

\li <b>\c TRACE_host_variable_declare (const char *variable)</b>:
Declare a user variable that will be associated to hosts. A variable can
be used to trace user variables such as the number of tasks in a server,
the number of clients in an application, and so on.

\li <b>\c TRACE_host_variable_[set|add|sub] (const char *variable, double
value)</b>:
Set the value of a given user variable. It is important to remind that
the value of this variable is always associated to the host. The host
that will be used when these functions are called is the one returned by
the function \c MSG_host_self().

\subsubsection faq_tracing_example Example of Instrumentation

A simplified example using the tracing mandatory functions.

\verbatim
int main (int argc, char **argv)
{
  TRACE_start ("traced_simulation.trace");
  TRACE_category ("request");
  TRACE_category ("computation");
  TRACE_category ("finalize");
  
  MSG_global_init (&argc, &argv);

  //(... after deployment ...)

  m_task_t req1 = MSG_task_create("1st_request_task", 10, 10, NULL);
  m_task_t req2 = MSG_task_create("2nd_request_task", 10, 10, NULL);
  m_task_t req3 = MSG_task_create("3rd_request_task", 10, 10, NULL);
  m_task_t req4 = MSG_task_create("4th_request_task", 10, 10, NULL);
  TRACE_msg_set_task_category (req1, "request");
  TRACE_msg_set_task_category (req2, "request");
  TRACE_msg_set_task_category (req3, "request");
  TRACE_msg_set_task_category (req4, "request");

  m_task_t comp = MSG_task_create ("comp_task", 100, 100, NULL);
  TRACE_msg_set_task_category (comp, "computation");

  m_task_t finalize = MSG_task_create ("finalize", 0, 0, NULL);
  TRACE_msg_set_task_category (finalize, "finalize");

  //(...)

  MSG_clean();
 
  TRACE_end();
  return 0;
}
\endverbatim

\subsubsection faq_tracing_analyzing Analyzing the SimGrid Traces

The SimGrid library, during an instrumented simulation, creates a trace file in
the Paje file format that contains the platform utilization for the simulation
that was executed. The visualization analysis of this file is performed with the
visualization tool <a href="http://triva.gforge.inria.fr">Triva</a>, with
special configurations tunned to SimGrid needs. This part of the documentation
explains how to configure and use Triva to analyse a SimGrid trace file.

- <b>Installing Triva</b>: the tool is available in the INRIAGforge, 
at <a href="http://triva.gforge.inria.fr">http://triva.gforge.inria.fr</a>.
Use the following command to get the sources, and then check the file
<i>INSTALL.simplified</i>. This file contains instructions to install
the tool's dependencies in a Ubuntu/Debian Linux.
\verbatim
$ svn checkout svn://scm.gforge.inria.fr/svn/triva
$ cd triva
$ cat INSTALL.simplified
\endverbatim

- <b>Executing Triva</b>: a binary called <i>Triva</i> is available after the
  installation (you can execute it passing <em>--help</em> to check its
options). If the triva binary is not available after following the
installation instructions, you may want to execute the following command to
initialize the GNUstep environment variables (note that the location of the
<i>GNUstep.sh</i> file may vary depending on your GNUstep installation - the
command is known to work in Ubuntu and Debian Linux):
\verbatim
$ source /usr/share/GNUstep/Makefiles/GNUstep.sh
\endverbatim
You should be able to see this output after the installation of triva:
\verbatim
$ ./Triva.app/Triva --help
Usage: Triva [OPTION...] TRACEFILE
Trace Analysis through Visualization

 You need to use one of the following options:
  -g, --graph                Graph Analysis
  -t, --treemap              Treemap Analysis

 Other auxiliary options to check the trace file:
  -c, --check                Check the integrity of trace file
  -h, --hierarchy            Export the trace type hierarchy
  -l, --list                 List entity types

  -?, --help                 Give this help list
      --usage                Give a short usage message
\endverbatim
Triva expects that the user choose one of the available options 
(currently <em>--graph</em> or <em>--treemap</em> for a visualization analysis)
and the trace file from the simulation.

- <b>Understanding Triva - time-slice</b>: the analysis of a trace file using
  the tool always takes into account the concept of the <em>time-slice</em>.
This concept means that what is being visualized in the screen is always
calculated considering a specific time frame, with its beggining and end
timestamp. The time-slice is configured by the user and can be changed
dynamically through the window called <em>Time Interval</em> that is opened
whenever a trace file is being analyzed. The next figure depicts the time-slice
configuration window.
In the top of the window, in the space named <i>Trace Time</i>,
the two fields show the beggining of the trace (which usually starts in 0) and
the end (that depends on the time simulated by SimGrid). The middle of the
window, in the square named <i>Time Slice Configuration</i>, contains the
aspects related to the time-slice, including its <i>start</i> and its
<i>size</i>. The gray rectangle in the bottom of this part indicates the 
<i>current time-slice</i> that is considered for the drawings. If the checkbox 
<i>Update Drawings on Sliders Change</i> is not selected, the button
<i>Apply</i> must be clicked in order to inform triva that the
new time-slice must be considered. The bottom part of the window, in the space
indicated by the square <i>Time Slice Animation</i> can be used to advance
the time-frame automatically. The user configures the amount of time that the
time-frame will forward and how frequent this update will happen. Once this is
configured, the user clicks the <i>Play</i> button in order to see the dynamic
changes on the drawings.
<center>
\htmlonly
<a href="triva-time_interval.png" border=0><img src="triva-time_interval.png" width="50%" border=0></a>
\endhtmlonly
</center>
<b>Remarks:</b> when the trace has too many hosts or links, the computation to
take into account a new time-slice can be expensive. When this happens, the
<i>Frequency</i> parameter, but also updates caused by change on configurations
when the checkbox <i>Update Drawings on Sliders
Change</i> is selected will not be followed.

- <b>Understanding Triva - graph</b>: this part of the documention explains how
  to analyze the traces using the graph view of Triva, when the user executes
the tool passing <em>--graph</em> as parameter. Triva opens three windows when
this parameter is used: the <i>Time Interval</i> window (previously described),
the <i>Graph Representation</i> window, and the <em>Graph Configuration</em>
window. The Graph Representation is the window where drawings take place.
Initially, it is completely white waiting for a proper graph configuration input
by the user. We start the description of this type of analysis by describing the
<i>Graph Configuration</i> window (depicted below). By using a particular
configuration, triva
can be used to customize the graph drawing according to
the SimGrid trace that was created with user-specific categories. Before delving
into the details of this customization, let us first explain the major parts of
the graph configuration window. The buttons located in the top-right corner can
be used to delete, copy and create a new configuration. The checkbox in the
top-middle part of the window indicates if the configuration typed in the
textfield is syntactically correct (we are using the non-XML 
<a href="http://en.wikipedia.org/wiki/Property_list">Property List Format</a> to
describe the configuration). The pop-up button located on the top-left corner 
indicates the selected configuration (the user can have multiple graph
configurations). The bottom-left text field contains the name of the current
configuration (updates on this field must be followed by typing enter on the
keyboard to take into account the name change). The bottom-right <em>Apply</em>
button activates the current configuration, resulting on an update on the graph
drawings.
<center>
\htmlonly
<a href="triva-graph_configuration.png" border=0><img src="triva-graph_configuration.png" width="50%" border=0></a>
\endhtmlonly
</center>
<b>Basic SimGrid Configuration</b>: The figure shows in the big textfield the
basic configuration that should be used during the analysis of a SimGrid trace
file. The basic logic of the configuration is as follows:
\verbatim
{
  node = (HOST);
  edge = (LINK);
\endverbatim
The nodes of the graph will be created based on the <i>node</i> parameter, which
in this case is the different <em>"HOST"</em>s of the platform 
used to simulate. The <i>edge</i> parameter indicates that the edges of the
graph will be created based on the <em>"LINK"</em>s of the platform. After the
definition of these two parameters, the configuration must detail how
<em>HOST</em>s and <em>LINK</em>s should be drawn. For that, the configuration
must have an entry for each of the types used. For <em>HOST</em>, as basic
configuration, we have:
\verbatim
  HOST = {
    size = power;
    scale = global;
  };
\endverbatim
The parameter <em>size</em> indicates which variable from the trace file will be
used to define the size of the node HOST in the visualization. If the simulation
was executed with availability traces, the size of the nodes will be changed
according to these traces. The parameter <em>scale</em> indicates if the value
of the variable is <em>global</em> or <em>local</em>. If it is global, the value
will be relative to the power of all other hosts, if it is local, the value will
be relative locally.
For <em>LINK</em> we have:
\verbatim
  LINK = {
    src = SrcHost;
    dst = DstHost;
    
    size = bandwidth;
    scale = global;
  };
\endverbatim
For the types specified in the <em>edge</em> parameter (such as <em>LINK</em>),
the configuration must contain two additional parameters: <em>src</em> and
<em>dst</em> that are used to properly identify which nodes this edge is
connecting. The values <em>SrcHost</em> and <em>DstHost</em> are always present
in the SimGrid trace file and should not be changed in the configuration. The
parameter <em>size</em> for the LINK, in this case, is configured as the
variable <em>bandwidth</em>, with a <em>global</em> scale. The scale meaning
here is exactly the same used for nodes. The last parameter is the GraphViz
algorithm used to calculate the position of the nodes in the graph
representation.
\verbatim
  graphviz-algorithm = neato;
}
\endverbatim
<b>Customizing the Graph Representation</b>: triva is capable to handle
a customized graph representation based on the variables present in the trace
file. In the case of SimGrid, every time a category is created for tasks, two
variables in the trace file are defined: one to indicate node utilization (how
much power was used by that task category), and another to indicate link
utilization (how much bandwidth was used by that category). For instance, if the
user declares a category named <i>request</i>, there will be variables named
<b>p</b><i>request</i> and a <b>b</b><i>request</i> (<b>p</b> for power and
<b>b</b> for bandwidth). It is important to notice that the variable
<i>prequest</i> in this case is only available for HOST, and
<i>brequest</i> is only available for LINK. <b>Example</b>: suppose there are
two categories for tasks: request and compute. To create a customized graph
representation with a proportional separation of host and link utilization, use
as configuration for HOST and LINK this:
\verbatim
  HOST = {
    size = power;
    scale = global;
  
    sep_host = {
      type = separation;
      size = power;
      values = (prequest, pcomputation);
    };
  };

  LINK = {
    src = SrcHost;
    dst = DstHost;
    size = bandwidth;
    scale = global;

    sep_link = {
      type = separation;
      size = bandwidth;
      values = (brequest, bcomputation);
    };
  };
\endverbatim
Where <i>sep_host</i> contains a composition of type <i>separation</i> where
its max size is the <i>power</i> of the host and the variables <i>prequest</i>
and <i>pcomputation</i> are drawn proportionally to the size of the HOST. And
<i>sep_link</i> is also a separation where max is defined as the
<i>bandwidth</i> of the link, and the variables <i>brequest</i> and
<i>bcomputation</i> are drawn proportionally within a LINK.
<i>This configuration enables the analysis of resource utilization by MSG tasks,
and the identification of load-balancing issues, network bottlenecks, for
instance.</i> \n
<b>Other compositions</b>: besides <i>separation</i>, it is possible to use
other types of compositions, such as gradients, and colors, like this:
\verbatim
    gra_host = {
      type = gradient;
      scale = global;
      values = (numberOfTasks);
    };
    color_host = {
      type = color;
      values = (is_server);
    };
\endverbatim
Where <i>gra_host</i> creates a gradient within a node of the graph, using a
global scale and using as value a variable called <i>numberOfTasks</i>, that
could be declared by the user using the optional tracing functions of SimGrid.
If scale is global, the max and min value for the gradient will be equal to the
max and min numberOfTasks among all hosts, and if scale is local, the max and
min value based on the value of numberOfTasks locally in each host.
And <i>color_host</i> composition draws a square based on a positive value of
the variable <i>is_server</i>, that could also be defined by the user using the
SimGrid tracing functions. \n
<b>The Graph Visualization</b>: The next figure shows a graph visualization of a
given time-slice of the masterslave_forwarder example (present in the SimGrid
sources). The red color indicates tasks from the <i>compute</i> category. This
visualization was generated with the following configuration:
\verbatim
{
  node = (HOST);
  edge = (LINK);

  HOST = {
    size = power;
    scale = global;
  
    sep_host = {
      type = separation;
      size = power;
      values = (pcompute, pfinalize);
    };
  };
  LINK = {
    src = SrcHost;
    dst = DstHost;
    size = bandwidth;
    scale = global;

    sep_link = {
      type = separation;
      size = bandwidth;
      values = (bcompute, bfinalize);
    };
  };
  graphviz-algorithm = neato;
}
\endverbatim
<center>
\htmlonly
<a href="triva-graph_visualization.png" border=0><img src="triva-graph_visualization.png" width="50%" border=0></a>
\endhtmlonly
</center>

- <b>Understading Triva - colors</b>: An important issue when using Triva is how
  to define colors. To do that, we have to know which variables are defined in
the trace file generated by the SimGrid library. The parameter <em>--list</em> 
lists the variables for a given trace file:
\verbatim
$ Triva -l masterslave_forwarder.trace
iFile
c  platform
c    HOST
v     power
v     is_slave
v     is_master
v     task_creation
v     task_computation
v     pcompute
v     pfinalize
c    LINK
v     bandwidth
v     latency
v     bcompute
v     bfinalize
c  user_type
\endverbatim
We can see that HOST has seven variables (from power to pfinalize) and LINK has
four (from bandwidth to bfinalize). To define a red color for the
<i>pcompute</i> and <i>bcompute</i> (which are defined based on user category
<i>compute</i>), execute:
\verbatim
$ defaults write Triva 'pcompute Color' '1 0 0'
$ defaults write Triva 'bcompute Color' '1 0 0'
\endverbatim
Where the three numbers in each line are the RGB color with values from 0 to 1.

\subsection faq_modelchecking Model-Checking
\subsubsection faq_modelchecking_howto How to use it
To enable the experimental SimGrid model-checking support the program should
be executed with the command line argument 
\verbatim
--cfg=model-check:1 
\endverbatim
Properties are expressed as assertions using the function
\verbatim
void MC_assert(int prop);
\endverbatim

\subsection faq_binding_lua Lua Binding
Most of Simgrid modules require a  good level in C programming ,
 since simgrid is used to be as standard C library .
 Sometime ( for some reason or another ) developers prefer using some kind of easy scripts 
 (something like  lua ? Ruby ? ...?)  or a language easier to code with ( Java ? ) for their works ,
 which avoid dealing with C errors , and sometime an important  gain of time (coding-time?) .
Besides Java Binding , Lua  and Ruby bindings are available now( since version 3.4 of Simgrid )
for MSG Module , and we are currenlty working on bindings for other modules .


\subsubsection faq_binding_lua_about What is lua ?
Lua (Moon for portuguese !) is a lightweight, reflective, imperative and functional programming language,
 designed as a scripting language with extensible semantics as a primary goal.(see official web site <a href="http://www.lua.org">here</a>)
\subsubsection faq_binding_lua_why Why lua ?
Lua is a fast,portable and powerful script language , quite simple to use for developpers .
it combines procedural features with powerful data description facilities,
 by using a simple, yet powerful, mechanism of tables.
Lua has a relatively simple C API compared to other scripting languages,
and accordingly it provides a robust, easy to use it.
\subsubsection faq_binding_lua_simgrid How to use lua in Simgrid ?
Actually , the use of lua in Simgrid is quite simple , you have just to follow the same steps as coding with C in Simgird ,
 but this time , code with Lua ;) :
  - Coding functions coresponding to each process
  - loading the platforme/deployment XML file that describe the environment of simulation
  - and  Running the Simulation !!!
  
\subsubsection faq_binding_lua_example_master_slave Master/Slave Example
 \li Master Code
\verbatim
function Master(...)
  nb_task = arg[1];
  comp_size = arg[2];
  comm_size = arg[3];
  slave_count = arg[4]
  -- Dispatch the tasks
  for i=1,nb_task do
    tk = simgrid.Task.new("Task "..i,comp_size,comm_size);
    alias = "slave "..(i%slave_count);
    simgrid.info("Master sending " .. simgrid.Task.name(tk) .." To " .. alias .."");
    simgrid.Task.send(tk,alias);
    simgrid.info("Master done sending ".. simgrid.Task.name(tk) .." To " .. alias .."");
  end
  -- Sending Finalize Message To Others
  for i=0,slave_count-1 do
    alias = "slave "..i;
    simgrid.info("Master: sending finalize to "..alias);
    finalize = simgrid.Task.new("finalize",comp_size,comm_size);
    simgrid.Task.send(finalize,alias)
  end
end
\endverbatim
we mainly  use   simgrid.Task.new(task_name,computation_size,communication_size) to create our MSG Task , 
	 then simgrid.Task.send(task,alias) to send it .
we  use also simgrid.Task.name(task), to get the task's name . 

\li Slave Code
\verbatim
function Slave(...)
  local my_mailbox="slave "..arg[1]
  while true do
    local tk = simgrid.Task.recv(my_mailbox);
    if (simgrid.Task.name(tk) == "finalize") then
      simgrid.info("Slave " ..my_mailbox.." got finalize msg");
      break
    end
    simgrid.Task.execute(tk)
  end
  simgrid.info("Slave " ..my_mailbox..": Im Done . See You !!");
end
\endverbatim
Here , we could see how we use  simgrid.Task.recv(alias) to receive a task with a specific alias ,
this function return directly the task recevied .

\li Set Environmenet and run application
\verbatim
require "simgrid"
simgrid.platform("my_platform.xml")
simgrid.application("my_deployment.xml")
simgrid.run()
simgrid.info("Simulations over.See you.")
simgrid.clean()
\endverbatim

\subsubsection faq_binding_lua_example_data Exchanging Data
You can also exchange data between Process using lua .for that , you have to deal with  lua task as a table ,
since lua is based itself on a mechanism of tables ,
so  you can exchange any kind of data ( tables, matrix , strings  ) between process via tasks.

\li Sender process
\verbatim 
  task = simgrid.Task.new("data_task",task_comp,task_comm);
  task['matrix'] = my_matrix;
  task['table'] = my_table;
  task['message'] = "Hello from (Lua || Simgrid ) !! "
  
  simgrid.Task.send(task,alias)
\endverbatim
	After creating task , we associate to it  various kind of data with a specific key , ( string in this case)
	to distinguish between data variables . Via this key the receiver could access easily to  datas .


\li Receiver processe
\verbatim
  task = simgrid.Task.recv(alias);
  sender_matrix = task['matrix'];
  sender_table = task['table'];
  sender_message = task['message']
  ...
\endverbatim
  	Note that in lua , both sender and receiver share the same lua task ! 
	So that the receiver could joint data directly on the received task without sending it back .
	You can find  a complet example ( matrix multiplication case ) in the file example/lua/mult_matrix.lua 


\subsubsection faq_binding_lua_example_bypass Bypass XML
	maybe you wonder if there is a way to bypass the XML files ,
	 and describe your platform directly from the code , with lua bindings it's Possible !! how ?
	We provide some additional (tricky?) functions in lua that allows you to set up your own platform without using the XML files
     ( this can be useful for large platforms , so a simple for loop will avoid you to deal with an annoying XML File ;) )
     

\li set Hosts
\verbatim
  simgrid.Host.new("Tremblay",98095000);
  simgrid.Host.new("Jupiter",76296000);
  simgrid.Host.new("Fafard",76296000);
  simgrid.Host.new("Ginette",48492000);
  simgrid.Host.new("Bourassa",48492000);
\endverbatim
  we use simgrid.Host.new(host_id,power) to instanciate our hosts.

\li set Links
\verbatim
  for i=0,11 do
    simgrid.Link.new(i,252750+ i*768,0.000270544+i*0.087);    --  some crazy values ;)
  end
\endverbatim
  we used simgrid.Link.new(link_id,bandwidth,latency) with a simple for loop to create all links we need  ( much easier than XML hein ? )

\li set Routes
\verbatim
-- simgrid.Route.new(src_id,des_id,links_nb,links_list)
   simgrid.Route.new("Tremblay","Jupiter",1,{"1"});
   simgrid.Route.new("Tremblay","Fafard",6,{"0","1","2","3","4","8"});
   simgrid.Route.new("Tremblay","Ginette",3,{"3","4","5"});
   simgrid.Route.new("Tremblay","Bourassa",7,{"0","1","3","2","4","6","7"});

   simgrid.Route.new("Jupiter","Tremblay",1,{"1"});
   simgrid.Route.new("Jupiter","Fafard",7,{"0","1","2","3","4","8","9"});
   simgrid.Route.new("Jupiter","Ginette",4,{"3","4","5","9"});
   simgrid.Route.new("Jupiter","Bourassa",8,{"0","1","2","3","4","6","7","9"});
   ...
\endverbatim
  for each host you have to specify which route to choose to access to the rest of hosts connected in the grid .
  
\li Save platform
\verbatim
  simgrid.register_platform();
\endverbatim
Don't forget to register your platform , that SURF callbacks starts their work ;)

\li set application
\verbatim
   simgrid.Host.setFunction("Tremblay","Master",4,{"20","550000000","1000000","4"});
   simgrid.Host.setFunction("Bourassa","Slave",1,{"0"});
   simgrid.Host.setFunction("Jupiter","Slave",1,{"1"});
   simgrid.Host.setFunction("Fafard","Slave",1,{"2"});
   simgrid.Host.setFunction("Ginette","Slave",1,{"3"});
\endverbatim
  you don't  need to use a deployment XML file , thanks to  simgrid.Host.setFunction(host_id,function,args_number,args_list) 
  you can associate functions for each host with arguments if needed .

\li
\verbatim
   simgrid.register_application();
\endverbatim
Yes , Here too you have to resgiter your application before running the simulation .

the full example is distributed in the file examples/lua/master_slave_bypass.lua

\section faq_troubleshooting Troubleshooting

\subsection faq_trouble_lib_compil SimGrid compilation and installation problems

\subsubsection faq_trouble_lib_config ./configure fails!

We know only one reason for the configure to fail:

 - <b>You are using a broken build environment</b>\n
   If symptom is that configure complains about gcc not being able to build
   executables, you are probably missing the libc6-dev package. Damn Ubuntu.

If you experience other kind of issue, please get in touch with us. We are
always interested in improving our portability to new systems.

\subsubsection faq_trouble_distcheck Dude! "make check" fails on my machine!

Don't assume we never run this target, because we do. Check
http://bob.loria.fr:8010 if you don't believe us.

There is several reasons which may cause the make check to fail on your
machine:

 - <b>You are using a broken libc (probably concerning the contextes)</b>.\n
   The symptom is that the "make check" fails within the examples/msg directory.\n
   By default, SimGrid uses something called ucontexts. This is part of the
   libc, but it's quite undertested. For example, some (old) versions of the
   glibc on alpha do not implement these functions, but provide the stubs
   (which return ENOSYS: not implemented). It may fool our detection mechanism
   and leads to segfaults. There is not much we can do to fix the bug.
   A workaround is to compile with --with-context=pthread to avoid
   ucontext completely. You'll be a bit more limited in the number
   of simulated processes you can start concurrently, but 5000
   processes is still enough for most purposes, isn't it?\n
   This limitation is the reason why we insist on using this piece of ...
   software even if it's so troublesome.\n
   <b>=> use --with-pthread on AMD64 architecture that do not have an 
   ultra-recent libc.</b>
   
 - <b>There is a bug in SimGrid we aren't aware of</b>.\n
   If none of the above apply, please drop us a mail on the mailing list so
   that we can check it out. Make sure to read \ref faq_bugrepport
   before you do so.

\subsection faq_trouble_compil User code compilation problems

\subsubsection faq_trouble_err_logcat "gcc: _simgrid_this_log_category_does_not_exist__??? undeclared (first use in this function)"

This is because you are using the log mecanism, but you didn't created
any default category in this file. You should refer to \ref XBT_log
for all the details, but you simply forgot to call one of
XBT_LOG_NEW_DEFAULT_CATEGORY() or XBT_LOG_NEW_DEFAULT_SUBCATEGORY().

\subsubsection faq_trouble_pthreadstatic "gcc: undefined reference to pthread_key_create"

This indicates that one of the library SimGrid depends on (libpthread
here) was missing on the linking command line. Dependencies of
libsimgrid are expressed directly in the dynamic library, so it's
quite impossible that you see this message when doing dynamic linking. 

If you compile your code statically (and if you use a pthread version
of SimGrid -- see \ref faq_more_processes), you must absolutely
specify <tt>-lpthread</tt> on the linker command line. As usual, this should
come after <tt>-lsimgrid</tt> on this command line.

\subsection faq_trouble_errors Runtime error messages

\subsubsection faq_flexml_limit "surf_parse_lex: Assertion `next limit' failed."

This is because your platform file is too big for the parser. 

Actually, the message comes directly from FleXML, the technology on top of
which the parser is built. FleXML has the bad idea of fetching the whole
document in memory before parsing it. And moreover, the memory buffer size
must be determined at compilation time.

We use a value which seems big enough for our need without bloating the
simulators footprints. But of course your mileage may vary. In this case,
just edit src/surf/surfxml.l modify the definition of
FLEXML_BUFFERSTACKSIZE. E.g.

\verbatim
#define FLEXML_BUFFERSTACKSIZE 1000000000
\endverbatim

Then recompile and everything should be fine, provided that your version of
Flex is recent enough (>= 2.5.31). If not the compilation process should
warn you.

A while ago, we worked on FleXML to reduce a bit its memory consumption, but
these issues remain. There is two things we should do:

  - use a dynamic buffer instead of a static one so that the only limit
    becomes your memory, not a stupid constant fixed at compilation time
    (maybe not so difficult).
  - change the parser so that it does not need to get the whole file in
    memory before parsing
    (seems quite difficult, but I'm a complete newbe wrt flex stuff).

These are changes to FleXML itself, not SimGrid. But since we kinda hijacked
the development of FleXML, I can grant you that any patches would be really
welcome and quickly integrated.

<b>Update:</b> A new version of FleXML (1.7) was released. Most of the work
was done by William Dowling, who use it in his own work. The good point is
that it now use a dynamic buffer, and that the memory usage was greatly
improved. The downside is that William also changed some things internally,
and it breaks the hack we devised to bypass the parser, as explained in 
\ref faq_flexml_bypassing. Indeed, this is not a classical usage of the
parser, and Will didn't imagine that we may have used (and even documented)
such a crude usage of FleXML. So, we now have to repair the bypassing
functionality to use the lastest FleXML version and fix the memory usage in
SimGrid.

\subsubsection faq_trouble_gras_transport GRAS spits networking error messages

Gras, on real platforms, naturally use regular sockets to communicate. They
are deeply hidden in the gras abstraction, but when things go wrong, you may
get some weird error messages. Here are some example, with the probable
reason:

 - <b>Transport endpoint is not connected</b>: several processes try to open
   a server socket on the same port number of the same machine. This is
   naturally bad and each process should pick its own port number for this.\n
   Maybe, you just have some processes remaining from a previous experiment 
   on your machine.\n
   Killing them may help, but again if you kill -KILL them, you'll have to
   wait for a while: they didn't close there sockets properly and the system
   needs a while to notice that this port is free again.

 - <b>Socket closed by remote side</b>: if the remote process is not
   supposed to close the socket at this point, it may be dead.
   
 - <b>Connection reset by peer</b>: I found this on Internet about this
   error. I think it's what's happening here, too:\n   
   <i>This basically means that a network error occurred while the client was
   receiving data from the server. But what is really happening is that the
   server actually accepts the connection, processes the request, and sends
   a reply to the client. However, when the server closes the socket, the
   client believes that the connection has been terminated abnormally
   because the socket implementation sends a TCP reset segment telling the
   client to throw away the data and report an error.\n
   Sometimes, this problem is caused by not properly closing the
   input/output streams and the socket connection. Make sure you close the
   input/output streams and socket connection properly. If everything is
   closed properly, however, and the problem persists, you can work around
   it by adding a one-second sleep before closing the streams and the
   socket. This technique, however, is not reliable and may not work on all
   systems.</i>\n
   Since GRAS sockets are closed properly (repeat after me: there is no bug
   in GRAS), it is either that you are closing your sockets on server side
   before the client get a chance to read them (use gras_os_sleep() to delay
   the server), or the server died awfully before the client got the data.

\subsubsection faq_trouble_errors_big_fat_warning I'm told that my XML files are too old.

The format of the XML platform description files is sometimes
improved. For example, we decided to change the units used in SimGrid
from MBytes, MFlops and seconds to Bytes, Flops and seconds to ease
people exchanging small messages. We also reworked the route
descriptions to allow more compact descriptions.

That is why the XML files are versionned using the 'version' attribute
of the root tag. Currently, it should read:
\verbatim
  <platform version="2">
\endverbatim

If your files are too old, you can use the simgrid_update_xml.pl
script which can be found in the tools directory of the archive.

\subsection faq_trouble_valgrind Valgrind-related and other debugger issues

If you don't, you really should use valgrind to debug your code, it's
almost magic.

\subsubsection faq_trouble_vg_longjmp longjmp madness in valgrind

This is when valgrind starts complaining about longjmp things, just like:

\verbatim ==21434== Conditional jump or move depends on uninitialised value(s)
==21434==    at 0x420DBE5: longjmp (longjmp.c:33)
==21434==
==21434== Use of uninitialised value of size 4
==21434==    at 0x420DC3A: __longjmp (__longjmp.S:48)
\endverbatim

This is the sign that you didn't used the exception mecanism well. Most
probably, you have a <tt>return;</tt> somewhere within a <tt>TRY{}</tt>
block. This is <b>evil</b>, and you must not do this. Did you read the section
about \ref XBT_ex??

\subsubsection faq_trouble_vg_libc Valgrind spits tons of errors about backtraces!

It may happen that valgrind, the memory debugger beloved by any decent C
programmer, spits tons of warnings like the following :
\verbatim ==8414== Conditional jump or move depends on uninitialised value(s)
==8414==    at 0x400882D: (within /lib/ld-2.3.6.so)
==8414==    by 0x414EDE9: (within /lib/tls/i686/cmov/libc-2.3.6.so)
==8414==    by 0x400B105: (within /lib/ld-2.3.6.so)
==8414==    by 0x414F937: _dl_open (in /lib/tls/i686/cmov/libc-2.3.6.so)
==8414==    by 0x4150F4C: (within /lib/tls/i686/cmov/libc-2.3.6.so)
==8414==    by 0x400B105: (within /lib/ld-2.3.6.so)
==8414==    by 0x415102D: __libc_dlopen_mode (in /lib/tls/i686/cmov/libc-2.3.6.so)
==8414==    by 0x412D6B9: backtrace (in /lib/tls/i686/cmov/libc-2.3.6.so)
==8414==    by 0x8076446: xbt_dictelm_get_ext (dict_elm.c:714)
==8414==    by 0x80764C1: xbt_dictelm_get (dict_elm.c:732)
==8414==    by 0x8079010: xbt_cfg_register (config.c:208)
==8414==    by 0x806821B: MSG_config (msg_config.c:42)
\endverbatim

This problem is somewhere in the libc when using the backtraces and there is
very few things we can do ourselves to fix it. Instead, here is how to tell
valgrind to ignore the error. Add the following to your ~/.valgrind.supp (or
create this file on need). Make sure to change the obj line according to
your personnal mileage (change 2.3.6 to the actual version you are using,
which you can retrieve with a simple "ls /lib/ld*.so").

\verbatim {
   name: Backtrace madness
   Memcheck:Cond
   obj:/lib/ld-2.3.6.so
   fun:dl_open_worker
   fun:_dl_open
   fun:do_dlopen
   fun:dlerror_run
   fun:__libc_dlopen_mode
}\endverbatim

Then, you have to specify valgrind to use this suppression file by passing
the <tt>--suppressions=$HOME/.valgrind.supp</tt> option on the command line.
You can also add the following to your ~/.bashrc so that it gets passed
automatically. Actually, it passes a bit more options to valgrind, and this
happen to be my personnal settings. Check the valgrind documentation for
more information.

\verbatim export VALGRIND_OPTS="--leak-check=yes --leak-resolution=high --num-callers=40 --tool=memcheck --suppressions=$HOME/.valgrind.supp" \endverbatim

\subsubsection faq_trouble_backtraces Truncated backtraces

When debugging SimGrid, it's easier to pass the
--disable-compiler-optimization flag to the configure if valgrind or
gdb get fooled by the optimization done by the compiler. But you
should remove these flag when everything works before going in
production (before launching your 1252135 experiments), or everything
will run only one half of the true SimGrid potential.

\subsection faq_deadlock There is a deadlock in my code!!!

Unfortunately, we cannot debug every code written in SimGrid.  We
furthermore believe that the framework provides ways enough
information to debug such informations yourself. If the textual output
is not enough, Make sure to check the \ref faq_visualization FAQ entry to see
how to get a graphical one.

Now, if you come up with a really simple example that deadlocks and
you're absolutely convinced that it should not, you can ask on the
list. Just be aware that you'll be severely punished if the mistake is
on your side... We have plenty of FAQ entries to redact and new
features to implement for the impenitents! ;)

\subsection faq_surf_network_latency I get weird timings when I play with the latencies.

OK, first of all, remember that units should be Bytes, Flops and
Seconds. If you don't use such units, some SimGrid constants (e.g. the
SG_TCP_CTE_GAMMA constant used in most network models) won't have the
right unit and you'll end up with weird results.

Here is what happens with a single transfer of size L on a link
(bw,lat) when nothing else happens.

\verbatim
0-----lat--------------------------------------------------t
|-----|**** real_bw =min(bw,SG_TCP_CTE_GAMMA/(2*lat)) *****|
\endverbatim

In more complex situations, this min is the solution of a complex
max-min linear system.  Have a look 
<a href="http://lists.gforge.inria.fr/pipermail/simgrid-devel/2006-April/thread.html">here</a>
and read the two threads "Bug in SURF?" and "Surf bug not
fixed?". You'll have a few other examples of such computations. You
can also read "A Network Model for Simulation of Grid Application" by
Henri Casanova and Loris Marchal to have all the details. The fact
that the real_bw is smaller than bw is easy to understand. The fact
that real_bw is smaller than SG_TCP_CTE_GAMMA/(2*lat) is due to the
window-based congestion mechanism of TCP. With TCP, you can't exploit
your huge network capacity if you don't have a good round-trip-time
because of the acks...

Anyway, what you get is t=lat + L/min(bw,SG_TCP_CTE_GAMMA/(2*lat)).

  * if I you set (bw,lat)=(100 000 000, 0.00001), you get t =  1.00001 (you fully
use your link)
  * if I you set (bw,lat)=(100 000 000, 0.0001),  you get t =  1.0001 (you're on the
limit)
  * if I you set (bw,lat)=(100 000 000, 0.001),   you get t = 10.001  (ouch!)

This bound on the effective bandwidth of a flow is not the only thing
that may make your result be unexpected. For example, two flows
competing on a saturated link receive an amount of bandwidth inversely
proportional to their round trip time.

\subsection faq_bugrepport So I've found a bug in SimGrid. How to report it?

We do our best to make sure to hammer away any bugs of SimGrid, but this is
still an academic project so please be patient if/when you find bugs in it.
If you do, the best solution is to drop an email either on the simgrid-user
or the simgrid-devel mailing list and explain us about the issue.  You can
also decide to open a formal bug report using the
<a href="https://gforge.inria.fr/tracker/?atid=165&group_id=12&func=browse">relevant
interface</a>. You need to login on the server to get the ability to submit
bugs. 

We will do our best to solve any problem repported, but you need to help us
finding the issue. Just telling "it segfault" isn't enough. Telling "It
segfaults when running the attached simulator" doesn't really help either.
You may find the following article interesting to see how to repport
informative bug repports:
http://www.chiark.greenend.org.uk/~sgtatham/bugs.html (it is not SimGrid
specific at all, but it's full of good advices).

\author Arnaud Legrand (arnaud.legrand::imag.fr)
\author Martin Quinson (martin.quinson::loria.fr)


*/

******************************************************************
*              OLD CRUFT NOT USED ANYMORE                        *
******************************************************************


\subsection faq_crosscompile Cross-compiling a Windows DLL of SimGrid from linux

At the moment, we do not distribute Windows pre-compiled version of SimGrid
because the support for this platform is still experimental. We know that
some parts of the GRAS environment do not work, and we think that the others
environments (MSG and SD) have good chances to work, but we didn't test
ourselves. This section explains how we generate the SimGrid DLL so that you
can build it for yourself. First of all, you need to have a version more
recent than 3.1 (ie, a SVN version as time of writting).

In order to cross-compile the package to windows from linux, you need to
install mingw32 (minimalist gnu win32). On Debian, you can do so by
installing the packages mingw32 (compiler), mingw32-binutils (linker and
so), mingw32-runtime.

You can use the VPATH support of configure to compile at the same time for
linux and windows without dupplicating the source nor cleaning the tree
between each. Just run bootstrap (if you use the SVN) to run the autotools.
Then, create a linux and a win directories. Then, type:
\verbatim  cd linux; ../configure --srcdir=.. <usual configure flags>; make; cd ..
cd win;  ../configure --srcdir=.. --host=i586-mingw32msvc <flags>; make; cd ..
\endverbatim
The trick to VPATH builds is to call configure from another directory,
passing it an extra --srcdir argument to tell it where all the sources are.
It will understand you want to use VPATH. Then, the trick to cross-compile
is simply to add a --host argument specifying the target you want to build
for. The i586-mingw32msvc string is what you have to pass to use the mingw32
environment as distributed in Debian.

After that, you can run all make targets from both directories, and test
easily that what you change for one arch does not break the other one. 

It is possible that this VPATH build thing breaks from time to time in the
SVN since it's quite fragile, but it's granted to work in any released
version. If you experience problems, drop us a mail. 

Another possible source of issue is that at the moment, building the
examples request to use the gras_stub_generator tool, which is a compiled
program, not a script. In cross-compilation, you need to cross-execute with
wine for example, which is not really pleasant. We are working on this, but
in the meanwhile, simply don't build the examples in cross-compilation
(<tt>cd src</tt> before running make).
    
Program (cross-)compiled with mingw32 do request an extra DLL at run-time to be
usable. For example, if you want to test your build with wine, you should do
the following to put this library where wine looks for DLLs.
\verbatim 
cp /usr/share/doc/mingw32-runtime/mingwm10.dll.gz ~/.wine/c/windows/system/
gunzip ~/.wine/c/windows/system/mingwm10.dll.gz
\endverbatim

The DLL is built in src/.libs, and installed in the <i>prefix</i>/bin directory
when you run make install. 

If you want to use it in a native project on windows, you need to use 
simgrid.dll and mingwm10.dll. For each DLL, you need to build .def file
under linux (listing the defined symbols), and convert it into a .lib file
under windows (specifying this in a way that windows compilers like). To
generate the def files, run (under linux):
\verbatim echo "LIBRARY libsimgrid-0.dll" > simgrid.def
echo EXPORTS >> simgrid.def
nm libsimgrid-0.dll | grep ' T _' | sed 's/.* T _//' >> simgrid.def
nm libsimgrid-0.dll | grep ' D _' | sed 's/.* D _//' | sed 's/$/ DATA/' >> simgrid.def

echo "LIBRARY mingwm10.dll" > mingwm10.def
echo EXPORTS >> mingwm10.def
nm mingwm10.dll | grep ' T _' | sed 's/.* T _//' >> mingwm10.def
nm mingwm10.dll | grep ' D _' | sed 's/.* D _//' | sed 's/$/ DATA/' >> mingwm10.def
\endverbatim

To create the import .lib files, use the <tt>lib</tt> windows tool (from
MSVC) the following way to produce simgrid.lib and mingwm10.lib
\verbatim lib /def:simgrid.def
lib /def:mingwm10.def
\endverbatim

If you happen to use Borland C Builder, the right command line is the
following (note that you don't need any file.def to get this working).
\verbatim implib simgrid.lib libsimgrid-0.dll
implib mingwm10.lib mingwm10.dll
\endverbatim

Then, set the following parameters in Visual C++ 2005:
Linker -> Input -> Additional dependencies = simgrid.lib mingwm10.lib

Just in case you wonder how to generate a DLL from libtool in another
project, we added -no-undefined to any lib*_la_LDFLAGS variables so that
libtool accepts to generate a dynamic library under windows. Then, to make
it true, we pass any dependencies (such as -lws2 under windows or -lpthread
on need) on the linking line. Passing such deps is a good idea anyway so
that they get noted in the library itself, avoiding the users to know about
our dependencies and put them manually on their compilation line. Then we
added the AC_LIBTOOL_WIN32_DLL macro just before AC_PROG_LIBTOOL in the
configure.ac. It means that we exported any symbols which need to be.
Nowadays, functions get automatically exported, so we don't need to load our
header files with tons of __declspec(dllexport) cruft. We only need to do so
for data, but there is no public data in SimGrid so we are good.

